<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>çµµæ–‡å­—ã‚³ã‚¤ã‚³ã‚¤</title>
<style>
/* =========================================================
1. ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ ï¼† ã‚«ãƒ¼ãƒ‰ãƒ¬ã‚¤ãƒ¤ãƒ¼
========================================================= */
:root { --card-w: 80px; --card-h: 124px; }

/* é•·æŠ¼ã—ãƒ»ãƒ†ã‚­ã‚¹ãƒˆé¸æŠãƒ»é’ã„å½±ãƒ»ç”»åƒãƒ‰ãƒ©ãƒƒã‚°ã‚’å®Œå…¨ç¦æ­¢ */
body, html {
  margin: 0; padding: 0; height: 100dvh; overflow: hidden;
  background-color: #050202; font-family: 'Sawarabi Mincho', serif;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-drag: none;
}

/* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå´©å£Šã‚’é˜²ãã‚°ãƒªãƒƒãƒ‰é…åˆ†ã®æœ€é©åŒ– (v46 ã‚¹ãƒãƒ›å¯¾å¿œ) */
#game-container {
  display: grid;
  grid-template-rows: auto auto 1fr auto auto 140px auto;
  height: 100dvh; overflow: hidden;
  background: radial-gradient(ellipse at center, #1a0a0a 0%, #050202 100%);
  color: #cda869;
  padding-bottom: max(10px, env(safe-area-inset-bottom));
  gap: 5px;
  position: relative;
}

#card-layer { position: absolute; inset: 0; pointer-events: none; z-index: 100; overflow: hidden; }

/* çŠ¶æ…‹åˆ¶å¾¡ (TOPç”»é¢ã®é«˜ã•0æ½°ã‚Œå•é¡Œã‚’è§£æ±º) */
body.is-opening header, body.is-opening .message-section, body.is-opening #nav-area,
body.is-opening #opponent-section, body.is-opening #deck, body.is-opening #field-cards,
body.is-opening .hand-container, body.is-opening .bottom-controls { display: none !important; }
body.is-opening .main-area { border: none; box-shadow: none; background: transparent; margin-top: 5vh; height: 80vh; }
body.is-opening #field-cards-container::before { display: none; }

/* ã‚¿ãƒ¼ãƒ³æš—è»¢ */
#game-container::after {
  content: "ã‚ã„ã¦ã®ç•ªã§ã™..."; position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
  background: rgba(0, 0, 0, 0.6); color: #cda869; display: flex; align-items: center; justify-content: center;
  backdrop-filter: blur(2px); opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 2000; font-size: 1.5rem; letter-spacing: 0.2rem;
}
body.turn-opponent #game-container::after { opacity: 1; pointer-events: auto; }
body.turn-opponent #player-hand { filter: brightness(0.3) grayscale(0.5); pointer-events: none; }

/* UIãƒ­ãƒƒã‚¯ã¨æ“ä½œå¾…ã¡ãƒ†ã‚£ãƒƒã‚«ãƒ¼ */
.ui-locked { pointer-events: none !important; }
.ui-locked #field-cards-container, .ui-locked .hand-container, .ui-locked #deck { opacity: 0.9; transition: opacity 0.3s; }
@keyframes ticker-pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(0.98); } }
.waiting-input #system-log { animation: ticker-pulse 2s infinite ease-in-out; color: #ffa700; text-shadow: 0 0 10px #ffa700; }

/* =========================================================
2. UIãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
========================================================= */
.btn-gold, button { background: linear-gradient(to bottom, #e6c370 0%, #c09830 100%); border: 1px solid #8a6e20; box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 5px rgba(0,0,0,0.5); color: #3d2b00; padding: 8px 15px; font-weight: bold; border-radius: 50px; cursor: pointer; outline: none; }
.btn-gold:hover, button:hover { background: linear-gradient(to bottom, #f7d580 0%, #d4af37 100%); box-shadow: 0 0 15px rgba(212, 175, 55, 0.5); }
.btn-gold:active, button:active { transform: scale(0.95); filter: brightness(0.8); }

.hidden { display: none !important; }
.overlay-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 3000;
  display: flex; justify-content: center; align-items: flex-start !important; padding-top: 5vh; backdrop-filter: blur(4px);
}
.modal-box { background: rgba(26,26,26,0.95); padding: 40px; border: 2px solid #ffa700; border-radius: 12px; box-shadow: 0 0 30px rgba(0,0,0,0.8); min-width: 300px; text-align: center; }

#roles-modal-content {
  background: #0a0a0a; border-top: 4px solid #cda869; padding: 20px; width: 95%; max-width: 800px;
  border-radius: 4px; height: auto; max-height: 80vh; margin-top: 0; overflow: hidden; display: flex; flex-direction: column;
}
.modal-tabs { display: flex; border-bottom: 2px solid #4a3a2a; margin-bottom: 15px; flex-shrink: 0; }
.tab-btn { flex: 1; background: transparent; border: none; color: rgba(205, 168, 105, 0.5); padding: 10px 0; font-size: 1rem; cursor: pointer; transition: 0.3s; }
.tab-btn.active { color: #cda869; border-bottom: 3px solid #cda869; font-weight: bold; text-shadow: 0 0 10px rgba(205, 168, 105, 0.5); }
.tab-content { display: none; overflow-y: auto; flex-grow: 1; animation: fadeIn 0.3s ease-in-out; padding: 0 10px; }
.tab-content.active { display: block; }

/* ã‚¹ãƒãƒ›å‘ã‘ã‚¿ã‚¤ãƒˆãƒ«ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–åŒ– */
header, .top-game-title {
  font-size: clamp(1.8rem, 8vw, 2.5rem) !important;
  white-space: nowrap;
  line-height: 1.2;
}

/* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ãƒªã‚¢ã®é‡ãªã‚Šé˜²æ­¢ */
.message-section {
  min-height: 40px;
  padding: 5px 10px;
  background: rgba(0,0,0,0.5);
  border-radius: 10px;
  margin: 0 10px;
  z-index: 20;
  text-align: center; font-size: 1.1rem; display: flex; align-items: center; justify-content: center;
}

/* =========================================================
3. ç›¤é¢ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
========================================================= */
.main-area { position: relative; background: radial-gradient(ellipse at center, rgba(30,15,15,0.6) 0%, #050202 100%); box-shadow: inset 0 0 40px #000; border-radius: 12px; margin: 10px 5px; display: flex; align-items: center; justify-content: center; }
#field-cards-container { width: 100%; height: 100%; position: absolute; inset: 0; }
#field-cards-container::before { content: 'ğŸ´ å ´ - FIELD'; position: absolute; top: 10px; left: 15px; color: rgba(205, 168, 105, 0.6); font-size: 0.7rem; letter-spacing: 0.1rem; }

#deck { width: var(--card-w); height: var(--card-h); background: linear-gradient(135deg, #4b0000 0%, #1a0000 100%); border: 2px solid #ffa700; border-radius: 6px; position: absolute; top: 50%; right: 15px; transform: translateY(-50%) scale(0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 2px 2px 0 #300, 4px 4px 0 #200, 6px 6px 0 #100; cursor: pointer; transition: transform 0.2s; z-index: 10; pointer-events: auto; }
#deck:hover { transform: translateY(-50%) scale(0.85) translateX(-2px); }
#deck.active-guide { animation: deck-pulse 1.5s infinite; box-shadow: 0 0 20px #ffa700, 4px 4px 0 #200; }
@keyframes deck-pulse { 0%, 100% { transform: translateY(-50%) scale(0.85); box-shadow: 0 0 20px #ffa700, 4px 4px 0 #200; } 50% { transform: translateY(-50%) scale(0.9); box-shadow: 0 0 40px #ffa700, 6px 6px 0 #200; } }

.deck-rect-visual { width: 36px; height: 54px; border: 2px solid #cda869; background: rgba(255,255,255,0.05); border-radius: 4px; position: relative; }
.deck-rect-visual::after { content: ''; position: absolute; inset: 4px; border: 1px solid rgba(205, 168, 105, 0.4); }
#deck-count { position: absolute; bottom: 5px; right: 5px; font-size: 0.8rem; color: rgba(255, 167, 0, 0.6); font-weight: bold; }

#opponent-section, .hand-container { display: flex; align-items: center; justify-content: space-between; min-height: 110px; padding: 0 5px;}
.hand-container { flex-direction: row-reverse; background: linear-gradient(to top, rgba(26,5,5,0.8), transparent); }
#player-paired, #opponent-paired { width: 35%; height: 100px; position: relative; background: rgba(0,0,0,0.3); border-radius: 6px; }
#player-paired:empty::before { content: 'ğŸ´ ã‚ãªãŸã®ç²å¾—æœ­'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(205, 168, 105, 0.3); font-size: 0.7rem; width: 100%; text-align: center;}
#opponent-paired:empty::before { content: 'ğŸ¤– ã‚ã„ã¦ã®ç²å¾—æœ­'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(205, 168, 105, 0.2); font-size: 0.7rem; width: 100%; text-align: center;}
#player-hand, #opponent-hand { width: 60%; height: 100%; position: relative; }

/* =========================================================
4. ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ ï¼† ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
========================================================= */
.card {
  position: absolute; width: var(--card-w); height: var(--card-h); border-radius: 6px;
  background: linear-gradient(135deg, #1f0a0a 0%, #050202 100%);
  box-shadow: 3px 6px 12px rgba(0,0,0,0.9), inset 0 1px 1px rgba(255,255,255,0.2); border: 1px solid rgba(205, 168, 105, 0.5);
  cursor: pointer; overflow: hidden !important; pointer-events: auto;
  transition: left 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), top 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.3s, filter 0.3s;
}

/* 2æ®µéšã‚¿ãƒƒãƒ—ãƒ»ãƒ’ãƒ³ãƒˆãƒ»ãƒã‚¤ãƒ©ã‚¤ãƒˆ */
.card.focused { transform: translateX(-50%) translateY(-25px) scale(1.1) !important; z-index: 1000 !important; box-shadow: 0 10px 25px rgba(205, 168, 105, 0.6), 0 0 15px #ffa700 !important; border-color: #ffa700 !important; }
@keyframes hint-pulse-gold { 0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); filter: brightness(1.0); } 50% { box-shadow: 0 0 30px #ffa700, inset 0 0 20px #ffa700; filter: brightness(1.5); border-color: #fff !important; } }
.card.playable-hint { animation: hint-pulse-gold 1.5s infinite ease-in-out !important; z-index: 150 !important; }
@keyframes match-pulse { 0%, 100% { box-shadow: 0 0 20px #a8c0ff, inset 0 0 10px #fff; } 50% { box-shadow: 0 0 40px #a8c0ff, 0 0 80px rgba(255,255,255,0.6), inset 0 0 20px #fff; } }
.card.match-highlight { border-color: #ffffff !important; animation: match-pulse 1s infinite ease-in-out !important; transform: translate(-50%, -50%) scale(1.2) !important; z-index: 600 !important; }
.card.dimmed { filter: brightness(0.3) grayscale(0.5) !important; transform: translate(-50%, -50%) scale(0.95) !important; transition: 0.3s; }

/* é­…ã›ã‚‹è‡ªå‹•ç²å¾—ã®ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
@keyframes capture-flash { 0% { box-shadow: 0 0 20px #fff; filter: brightness(1); } 50% { box-shadow: 0 0 80px #fff, inset 0 0 40px #fff; filter: brightness(2); border-color: #fff; } 100% { box-shadow: 0 0 20px #fff; filter: brightness(1); } }
.card.capture-flash { animation: capture-flash 1s ease-in-out !important; z-index: 2000 !important; }
.telegraph-glow { transform: translateX(-50%) translateY(-15px) scale(1.05) !important; box-shadow: 0 0 25px #ff3333, inset 0 0 10px #ff3333 !important; border-color: #ff3333 !important; z-index: 1000 !important; }

.card.hikari { border: 1px solid #cda869 !important; box-shadow: inset 0 0 15px rgba(205, 168, 105, 0.8) !important; }
.card-watermark { display: none !important; }
.card-month-number { position: absolute; top: 4px; left: 6px; font-size: 1.1rem; font-weight: 900; color: rgba(205, 168, 105, 0.9); z-index: 3; text-shadow: 0 2px 4px rgba(0,0,0,0.8); font-family: sans-serif; pointer-events: none; }

/* ã‚«ãƒ¼ãƒ‰å†…ã®çµµæ–‡å­—ã‚’å®Œå…¨ã«ä¸­å¤®ã«å›ºå®š */
.card-inner-art {
  position: absolute;
  inset: 0;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 2; pointer-events: none;
}
.emoji-main {
  font-size: clamp(2rem, 10vw, 3rem); line-height: 1;
  text-align: center;
  filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); pointer-events: none;
}

.card.akatan { background: linear-gradient(135deg, #4a0d0d 0%, #2b0000 100%); border-color: #ff4d4d; }
.card.aotan { background: linear-gradient(135deg, #0d1b4a 0%, #00092b 100%); border-color: #4d4dff; }
.card.tanzaku:not(.akatan):not(.aotan) { background: linear-gradient(135deg, #2a2a2a 0%, #111 100%); border-color: #aaa; }
.card.tanzaku::after { content: ''; position: absolute; left: 8px; width: 6px; height: 100%; z-index: 1; opacity: 0.7; pointer-events: none; }
.card.akatan::after { background: #ff4d4d; }
.card.aotan::after { background: #4d4dff; }
.card.tanzaku:not(.akatan):not(.aotan)::after { background: #aaa; }

/* å„æœˆã®ãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼ã‚’ã‚«ãƒ¼ãƒ‰ä¸‹éƒ¨ã‹ã‚‰æ¥µè–„ã§ç™ºå…‰ã•ã›ã‚‹ */
.card.month-1 { background: radial-gradient(circle at bottom, rgba(34, 139, 34, 0.3) 0%, #050202 80%); }
.card.month-2 { background: radial-gradient(circle at bottom, rgba(220, 20, 60, 0.3) 0%, #050202 80%); }
.card.month-3 { background: radial-gradient(circle at bottom, rgba(255, 183, 197, 0.3) 0%, #050202 80%); }
.card.month-4 { background: radial-gradient(circle at bottom, rgba(138, 43, 226, 0.3) 0%, #050202 80%); }
.card.month-5 { background: radial-gradient(circle at bottom, rgba(72, 61, 139, 0.3) 0%, #050202 80%); }
.card.month-6 { background: radial-gradient(circle at bottom, rgba(199, 21, 133, 0.3) 0%, #050202 80%); }
.card.month-7 { background: radial-gradient(circle at bottom, rgba(210, 105, 30, 0.3) 0%, #050202 80%); }
.card.month-8 { background: radial-gradient(circle at bottom, rgba(255, 215, 0, 0.3) 0%, #050202 80%); }
.card.month-9 { background: radial-gradient(circle at bottom, rgba(255, 140, 0, 0.3) 0%, #050202 80%); }
.card.month-10 { background: radial-gradient(circle at bottom, rgba(178, 34, 34, 0.3) 0%, #050202 80%); }
.card.month-11 { background: radial-gradient(circle at bottom, rgba(0, 100, 0, 0.3) 0%, #050202 80%); }
.card.month-12 { background: radial-gradient(circle at bottom, rgba(75, 0, 130, 0.3) 0%, #050202 80%); }

/* ç›¸æ‰‹ã®æ‰‹æœ­éš è”½ï¼ˆèƒŒæ™¯åŒåŒ–ã®é˜²æ­¢ï¼‰ */
.role-opponent * { display: none !important; }
.role-opponent::after, .role-opponent::before { display: none !important; }
.role-opponent { background: repeating-linear-gradient(45deg, #150505, #150505 8px, #050000 8px, #050000 16px) !important; border: 1px solid rgba(205, 168, 105, 0.4) !important; box-shadow: 3px 6px 12px rgba(0,0,0,0.9), inset 0 1px 1px rgba(255,255,255,0.1) !important; }

/* å›³é‘‘ãƒªã‚»ãƒƒãƒˆ */
#roles-modal-content .card { position: relative !important; left: auto !important; top: auto !important; transform: none !important; margin: 0 auto; box-shadow: none; transition: 0.2s; }
#roles-modal-content .card:hover { transform: scale(1.1) !important; z-index: 10; }
.mini-card { width: 40px !important; height: 62px !important; border-radius: 4px; border: 1px solid #3d2b00; background-color: transparent !important; }
.mini-card .emoji-main { font-size: 1.2rem !important; }
.mini-card .card-month-number { font-size: 0.65rem; top: 1px; left: 2px; }
.mini-ref-wrapper.missing .mini-card { filter: grayscale(1) brightness(0.4); opacity: 0.6; }
.mini-ref-wrapper.collected .mini-card { box-shadow: 0 0 8px rgba(205,168,105,0.6) !important; border-color: #ffa700 !important; }

/* ãƒ«ãƒ¼ãƒ«ã®æœ­ã¯1.5å€ã«æ‹¡å¤§ */
#tab-rule .mini-card { width: 54px !important; height: 84px !important; border-color: #cda869 !important; background: linear-gradient(135deg, #2a1a1a, #050202) !important; margin-bottom: 5px; }
#tab-rule .emoji-main { font-size: 1.8rem !important; }

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
@keyframes text-pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
@keyframes fall { 0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(110vh) rotate(720deg); opacity: 0; } }
@keyframes butterfly-fly { 0% { transform: translate(0, 0) scale(0.5) rotate(0deg); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(1.5) rotate(360deg); opacity: 0; } }

#game-container.celebration-mode { background: radial-gradient(circle, #4d0000 0%, #1a0000 100%) !important; }
#celebration-role-name { font-size: 2.5rem; color: #ffa700; text-shadow: 0 0 30px #ffa700, 0 0 50px gold; animation: text-pulse 1s infinite alternate; margin-bottom: 20px; }
#slot-score-display { font-size: 5rem; font-weight: bold; color: #ffa700; text-shadow: 0 0 20px gold; margin: 15px 0; }
.gold-particle { position: fixed; background: linear-gradient(135deg, #fff7ad 0%, #ffa700 50%, #b38b00 100%); pointer-events: none; z-index: 4000; opacity: 0.8; box-shadow: 0 0 5px gold; }
.butterfly-particle { position: fixed; font-size: 2rem; z-index: 4500; pointer-events: none; }
.divine-flash-overlay { position: fixed; inset: 0; background: white; z-index: 5000; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
.divine-flash-overlay.active { opacity: 1; }
.divine-fade-out { filter: brightness(2) contrast(1.5); transition: 0.5s; }

/* --- TOPç”»é¢åˆ·æ–°ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
#top-ui-area {
  position: absolute; inset: 0;
  background: radial-gradient(ellipse at center, #2a0a0a 0%, #050202 100%);
  display: flex; justify-content: center; align-items: center;
  overflow: hidden; z-index: 2000;
}
.top-content-wrapper {
  text-align: center; color: #cda869; z-index: 10;
  display: flex; flex-direction: column; align-items: center; gap: 25px;
  padding: 20px; width: 100%; max-width: 600px;
}
.top-game-title {
  font-size: 4rem; font-weight: 900; letter-spacing: 0.5rem; margin: 0;
  background: linear-gradient(to bottom, #ffd700, #cda869);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 15px rgba(205, 168, 105, 0.6));
}
.top-sub-title {
  font-size: 1.2rem; font-style: italic; color: #f0e68c; margin-top: 10px;
  text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
.top-visual-area {
  position: relative; height: 180px; width: 100%; max-width: 400px;
  margin: 20px auto; perspective: 1000px;
}
.floating-card {
  position: absolute; font-size: 5rem; top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  filter: drop-shadow(0 5px 15px rgba(0,0,0,0.5));
  animation: floating-cards 6s ease-in-out infinite alternate;
}
.card-1 { margin-left: -140px; margin-top: -20px; animation-delay: 0s; font-size: 4rem; opacity: 0.8; }
.card-2 { margin-left: -70px; margin-top: -40px; animation-delay: -1s; font-size: 4.5rem; opacity: 0.9; }
.card-3 { margin-top: -60px; animation-delay: -2s; z-index: 5; filter: drop-shadow(0 0 25px #ffa700); }
.card-4 { margin-left: 70px; margin-top: -40px; animation-delay: -3s; font-size: 4.5rem; opacity: 0.9; }
.card-5 { margin-left: 140px; margin-top: -20px; animation-delay: -4s; font-size: 4rem; opacity: 0.8; }
@keyframes floating-cards {
  0% { transform: translate(-50%, -50%) translateY(0px) rotate(0deg); }
  100% { transform: translate(-50%, -50%) translateY(-20px) rotate(5deg); }
}
.top-status-area {
  display: flex; gap: 15px; justify-content: center; width: 100%;
}
.status-box {
  background: rgba(255,255,255,0.05); border: 1px solid rgba(205, 168, 105, 0.3);
  padding: 10px 20px; border-radius: 8px;text-align: center;
  box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
}
.status-label { display: block; font-size: 0.8rem; color: #aaa; margin-bottom: 5px; }
.status-value { font-size: 1.1rem; font-weight: bold; color: #cda869; }
.top-start-btn {
  padding: 15px 60px; font-size: 1.5rem; margin-top: 10px;
  box-shadow: 0 0 25px rgba(255, 167, 0, 0.4);
}
.top-background-effect { position: absolute; inset: 0; pointer-events: none; }
.gold-particle-fall {
  position: absolute; width: 6px; height: 6px; background: #ffd700;
  border-radius: 50%; box-shadow: 0 0 5px #ffd700;
  animation: gold-fall linear infinite;
}
@keyframes gold-fall {
  0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
  100% { transform: translateY(110vh) rotate(360deg); opacity: 0; }
}
@media (max-width: 430px) { :root { --card-w: 60px; --card-h: 93px; } .btn-gold { font-size: 0.8rem; padding: 6px 12px;} .top-visual-area { transform: scale(0.8); } }
</style>
</head>
<body>

<div class="container" id="game-container">
  <div id="card-layer"></div>
  <div class="overlay-backdrop hidden" id="decision-overlay">
    <div id="role-completion-notification" class="modal-box hidden">
      <div id="celebration-owner" style="font-size: 1.2rem; color: #aaa; margin-bottom: 10px;"></div>
      <div id="celebration-role-name"></div>
      <div id="slot-score-display" class="hidden">0</div>
      <div id="role-decision-buttons" class="hidden">
        <button id="role-koikoi-btn" class="btn-gold" style="font-size: 1.2rem; padding: 15px 30px;">ğŸ²ã“ã„ã“ã„</button>
        <button id="role-win-btn" class="btn-gold" style="font-size: 1.2rem; padding: 15px 30px;">ğŸ‘‹å‹è² </button>
      </div>
    </div>
  </div>

  <div style="display: flex; justify-content: space-between; padding: 5px 10px;">
    <div>
      <button id="roles-btn" class="btn-gold">ğŸ“‹å½¹/å›³é‘‘/ãƒ«ãƒ¼ãƒ«</button>
      <button id="reset-btn" class="btn-gold hidden">ğŸ”„ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
    <header style="font-size: 1.5rem; font-weight: bold; color: #cda869; letter-spacing: 0.2rem;">çµµæ–‡å­—ã‚³ã‚¤ã‚³ã‚¤</header>
  </div>

  <div class="opponent-section" id="opponent-section">
    <div id="opponent-paired"></div><div id="opponent-hand"></div>
  </div>

  <div class="main-area">
    <div id="deck"><div class="deck-rect-visual"></div><span id="deck-count">24</span></div>
    <div class="field-cards" id="field-cards-container">
      
      <!-- TOP UI AREA -->
      <div id="top-ui-area">
        <div class="top-background-effect"></div>
        <div class="top-content-wrapper">
          <div class="top-title-area">
            <h1 class="top-game-title">çµµæ–‡å­—ã‚³ã‚¤ã‚³ã‚¤</h1>
            <p class="top-sub-title">ã€Œæ¥µä¸Šã®å‹è² ãŒã€ä»Šå§‹ã¾ã‚‹ã€‚ã€</p>
          </div>
          <div class="top-visual-area">
            <div class="floating-card card-1">ğŸâœ¨</div>
            <div class="floating-card card-2">ğŸŒ¸â›º</div>
            <div class="floating-card card-3 center-card">ğŸŒ•âœ¨</div>
            <div class="floating-card card-4">ğŸğŸ¦Œ</div>
            <div class="floating-card card-5">ğŸ¦…âœ¨</div>
          </div>
          <div class="top-status-area">
            <div class="status-box">
              <span class="status-label">ç¾åœ¨ã®åœ°ä½</span>
              <span class="status-value" id="top-rank-display">Fetching...</span>
            </div>
            <div class="status-box">
              <span class="status-label">å›³é‘‘åé›†ç‡</span>
              <span class="status-value" id="top-collection-display">Fetching...</span>
            </div>
          </div>
          <button id="start-btn" class="btn-gold top-start-btn">ä¸€å±€æ‰“ã¤</button>
        </div>
      </div>

      <div id="field-cards"></div>
    </div>
  </div>

  <div class="message-section">
    <div id="system-log">ğŸ¯æº–å‚™ãŒæ•´ã„ã¾ã—ãŸ</div>
  </div>
  
  <div id="nav-area" style="text-align: center; height: 35px; display: flex; align-items: center; justify-content: center; z-index: 50; position: relative;"></div>

  <div class="hand-container">
    <div id="player-hand"></div><div id="player-paired"></div>
  </div>

  <div class="bottom-controls" style="display: flex; justify-content: space-around; padding: 5px; background: rgba(0,0,0,0.5);">
    <div class="score-button"><div id="player-score">ğŸ˜¯ æŒã¡ç‚¹ ğŸ’° 0</div></div>
    <div class="score-button"><div id="opponent-score">ğŸ¤– æŒã¡ç‚¹ ğŸ’° 0</div></div>
  </div>
</div>

<div id="roles-modal-backdrop" class="overlay-backdrop hidden">
  <div id="roles-modal-content" class="roles-modal"></div>
</div>

<script>
const HYPER_DECK = [
{ id: "m01-h", month: 1, name: "æ¾ã«é¶´", symbol: "ğŸ¦¢âœ¨", type: "hikari", tags: ["light", "crane"] }, { id: "m01-t", month: 1, name: "æ¾ã«èµ¤çŸ­", symbol: "ğŸ”–ğŸ”´", type: "tanzaku", tags: ["akatan", "tanzaku"] },
{ id: "m02-n", month: 2, name: "æ¢…ã«é´¬", symbol: "ğŸ¦ğŸŒ¸", type: "tane", tags: ["bird"] }, { id: "m02-t", month: 2, name: "æ¢…ã«èµ¤çŸ­", symbol: "ğŸ”–ğŸ”´", type: "tanzaku", tags: ["akatan", "tanzaku"] },
{ id: "m03-h", month: 3, name: "æ¡œã«å¹•", symbol: "â›ºâœ¨", type: "hikari", tags: ["light", "curtain"] }, { id: "m03-t", month: 3, name: "æ¡œã«èµ¤çŸ­", symbol: "ğŸ”–ğŸ”´", type: "tanzaku", tags: ["akatan", "tanzaku"] },
{ id: "m04-n", month: 4, name: "è—¤ã«ä¸å¦‚å¸°", symbol: "ğŸ¦œğŸŒ¿", type: "tane", tags: ["bird"] }, { id: "m04-t", month: 4, name: "è—¤ã«çŸ­å†Š", symbol: "ğŸ—ï¸", type: "tanzaku", tags: ["tanzaku"] },
{ id: "m05-n", month: 5, name: "è–è’²ã«å…«æ©‹", symbol: "ğŸŒ‰", type: "tane", tags: ["bridge"] }, { id: "m05-t", month: 5, name: "è–è’²ã«çŸ­å†Š", symbol: "ğŸ—ï¸", type: "tanzaku", tags: ["tanzaku"] },
{ id: "m06-n", month: 6, name: "ç‰¡ä¸¹ã«è¶", symbol: "ğŸ¦‹ğŸŒº", type: "tane", tags: ["cho", "insect"] }, { id: "m06-t", month: 6, name: "ç‰¡ä¸¹ã«é’çŸ­", symbol: "ğŸ”–ğŸ”µ", type: "tanzaku", tags: ["aotan", "tanzaku"] },
{ id: "m07-n", month: 7, name: "è©ã«çŒª", symbol: "ğŸ—ğŸŒ¾", type: "tane", tags: ["ino", "beast"] }, { id: "m07-t", month: 7, name: "è©ã«çŸ­å†Š", symbol: "ğŸ—ï¸", type: "tanzaku", tags: ["tanzaku"] },
{ id: "m08-h", month: 8, name: "èŠ’ã«æœˆ", symbol: "ğŸŒ•âœ¨", type: "hikari", tags: ["light", "moon"] }, { id: "m08-n", month: 8, name: "èŠ’ã«é›", symbol: "ğŸ¦†ğŸŒ•", type: "tane", tags: ["bird"] },
{ id: "m09-n", month: 9, name: "èŠã«ç›ƒ", symbol: "ğŸ¶ğŸŒ•", type: "tane", tags: ["cup"] }, { id: "m09-t", month: 9, name: "èŠã«é’çŸ­", symbol: "ğŸ”–ğŸ”µ", type: "tanzaku", tags: ["aotan", "tanzaku"] },
{ id: "m10-n", month: 10, name: "ç´…è‘‰ã«é¹¿", symbol: "ğŸ¦ŒğŸ", type: "tane", tags: ["shika", "beast"] }, { id: "m10-t", month: 10, name: "ç´…è‘‰ã«é’çŸ­", symbol: "ğŸ”–ğŸ”µ", type: "tanzaku", tags: ["aotan", "tanzaku"] },
{ id: "m11-h", month: 11, name: "æŸ³ã«é“é¢¨", symbol: "ğŸŒ‚âœ¨", type: "hikari", tags: ["light", "rain"] }, { id: "m11-n", month: 11, name: "æŸ³ã«ç‡•", symbol: "ğŸ¦â˜”", type: "tane", tags: ["bird"] },
{ id: "m12-h", month: 12, name: "æ¡ã«é³³å‡°", symbol: "ğŸ¦…âœ¨", type: "hikari", tags: ["light", "phoenix"] }, { id: "m12-n", month: 12, name: "æ¡ã®å½¹æœ­", symbol: "ğŸŒ¿", type: "tane", tags: ["special"] }
];

class HyperJudge {
  constructor() {
    this.yakuMap = {
      "äº”å…‰": { tags: ["light"], count: 5, points: 20 }, "å››å…‰": { tags: ["light"], count: 4, points: 10 },
      "ä¸‰å…‰": { tags: ["light"], count: 3, points: 6 }, "çŒªé¹¿è¶": { tags: ["ino", "shika", "cho"], points: 10 },
      "èµ¤çŸ­": { tags: ["akatan"], count: 3, points: 7 }, "é’çŸ­": { tags: ["aotan"], count: 3, points: 7 }
    };
  }
  check(cards) {
    const results = [];
    const ids = cards.map(c => c.id);
    const myTags = cards.flatMap(c => c.tags || []);
    
    Object.entries(this.yakuMap).forEach(([name, rule]) => {
      const lightCount = myTags.filter(t => rule.tags && rule.tags.includes(t)).length;
      if (rule.tags && (rule.count ? lightCount >= rule.count : rule.tags.every(t => myTags.includes(t)))) {
        if(name==="ä¸‰å…‰" && lightCount >= 4) return;
        if(name==="å››å…‰" && lightCount >= 5) return;
        results.push({ name, points: rule.points });
      }
    });

    if (ids.includes("m03-h") && ids.includes("m09-n")) results.push({ name: "èŠ±è¦‹é…’", points: 5 });
    if (ids.includes("m08-h") && ids.includes("m09-n")) results.push({ name: "æœˆè¦‹é…’", points: 5 });

    const types = { tane: 0, tanzaku: 0 };
    cards.forEach(c => { if(types[c.type] !== undefined) types[c.type]++; });
    if (types.tane >= 3) results.push({ name: "ã‚¿ãƒ", points: types.tane - 2 });
    if (types.tanzaku >= 3) results.push({ name: "çŸ­å†Š", points: types.tanzaku - 2 });
    
    return results;
  }
}

class RecordManager {
  constructor() { this.key = 'KYOKU_DATA'; this.data = JSON.parse(localStorage.getItem(this.key)) || { points: 0, wins: 0, playCount: 0, collectedCardIds: [] }; }
  update(p, isWin) { this.data.points += p; if (isWin) this.data.wins++; this.data.playCount++; localStorage.setItem(this.key, JSON.stringify(this.data)); }
  updateCollection(cards) {
    let updated = false;
    cards.forEach(card => { if (!this.data.collectedCardIds.includes(card.id)) { this.data.collectedCardIds.push(card.id); updated = true; } });
    if (updated) localStorage.setItem(this.key, JSON.stringify(this.data));
  }
  getRank() {
    const count = this.data.collectedCardIds.length;
    if (count === 24) return "ğŸ‘‘ ä¸‡ç‰©åé›†ã®æ¥µã¿"; if (count >= 18) return "âœ¨ ç†Ÿç·´ã®åé›†å®¶";
    if (count >= 10) return "ğŸ´ ç²‹ãªéŠã³äºº"; if (count >= 1) return "ğŸŒ± è¦‹ç¿’ã„åé›†å®¶"; return "ğŸŒ± é–€å¤–æ¼¢";
  }
  getCollectionRate() { return this.data.collectedCardIds.length; }
}

class StatusSyncManager {
  constructor(game) { this.game = game; }
  sync() {
    const roundInfo = this.game.currentRound <= 3 ? `ã€ç¬¬ ${this.game.currentRound} / 3 å›æˆ¦ã€‘` : `ã€è©¦åˆçµ‚äº†ã€‘`;
    this.game.ui.pScore.innerHTML = `<span style="font-size:0.8rem; color:#aaa;">${roundInfo}</span><br>ğŸ˜¯ æŒã¡ç‚¹ ğŸ’° ${this.game.matchPointsP}`;
    this.game.ui.oScore.innerHTML = `<br>ğŸ¤– æŒã¡ç‚¹ ğŸ’° ${this.game.matchPointsO}`;
  }
  showEncyclopedia() {
    const modalContent = document.getElementById('roles-modal-content');
    modalContent.innerHTML = `
      <div class="modal-tabs">
        <button class="tab-btn active" data-target="tab-yaku">å½¹</button>
        <button class="tab-btn" data-target="tab-collection">å›³é‘‘</button>
        <button class="tab-btn" data-target="tab-rule">ãƒ«ãƒ¼ãƒ«</button>
      </div>
      <div id="tab-yaku" class="tab-content active"></div><div id="tab-collection" class="tab-content"></div><div id="tab-rule" class="tab-content"></div>
      <button id="roles-modal-close-btn" class="btn-gold" style="margin-top:15px; width:100%;">âŒé–‰ã˜ã‚‹</button>
    `;
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.onclick = (e) => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active')); document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        e.target.classList.add('active'); document.getElementById(e.target.dataset.target).classList.add('active');
      };
    });
    this.renderYakuTab(); this.renderCollectionTab(); this.renderRuleTab();
    document.getElementById('roles-modal-close-btn').onclick = () => document.getElementById('roles-modal-backdrop').classList.add('hidden');
    document.getElementById('roles-modal-backdrop').classList.remove('hidden');
  }
  createSampleCard(id) {
    const master = HYPER_DECK.find(d => d.id === id); let tanzakuClass = '';
    if (master.type === 'tanzaku') { if (master.tags.includes('akatan')) tanzakuClass = 'akatan'; else if (master.tags.includes('aotan')) tanzakuClass = 'aotan'; }
    return `<div class="card mini-card month-${master.month} ${master.type} ${tanzakuClass}">
<div class="card-month-number">${master.month}</div>
<div class="card-inner-art"><span class="emoji-main">${master.symbol}</span></div>
</div>`;
  }
  renderYakuTab() {
    const yakuRecipes = [
      { name: "äº”å…‰ (20æ–‡)", ids: ["m01-h", "m03-h", "m08-h", "m11-h", "m12-h"] },
      { name: "ä¸‰å…‰ãƒ»å››å…‰ (6ã€œ10æ–‡)", ids: ["m01-h", "m03-h", "m08-h", "m12-h"] },
      { name: "èŠ±è¦‹ã§ä¸€æ¯ (5æ–‡)", ids: ["m03-h", "m09-n"] },
      { name: "æœˆè¦‹ã§ä¸€æ¯ (5æ–‡)", ids: ["m08-h", "m09-n"] },
      { name: "çŒªé¹¿è¶ (10æ–‡)", ids: ["m06-n", "m07-n", "m10-n"] },
      { name: "èµ¤çŸ­ (7æ–‡)", ids: ["m01-t", "m02-t", "m03-t"] },
      { name: "é’çŸ­ (7æ–‡)", ids: ["m06-t", "m09-t", "m10-t"] }
    ];
    let html = '';
    yakuRecipes.forEach(recipe => {
      const cardsHTML = recipe.ids.map(id => this.createSampleCard(id)).join('');
      html += `<div class="yaku-box" style="margin-bottom:15px;"><div class="yaku-title" style="color:#ffa700; font-weight:bold; margin-bottom:5px;">${recipe.name}</div><div style="display:flex; gap:6px; flex-wrap:wrap;">${cardsHTML}</div></div>`;
    });
    html += `<div class="yaku-box"><div class="yaku-title" style="color:#ffa700; font-weight:bold; margin-bottom:5px;">ã‚¿ãƒãƒ»çŸ­å†Š (å„3æšã‹ã‚‰1æ–‡)</div><p style="font-size:0.8rem; color:#cda869; margin: 5px 0 0 0;">â€»è©²å½“å±æ€§ã‚’3æšé›†ã‚ã‚‹ã¨æˆç«‹ã€ä»¥é™1æšã”ã¨ã«+1æ–‡</p></div>`;
    document.getElementById('tab-yaku').innerHTML = html;
  }
  renderCollectionTab() {
    document.getElementById('tab-collection').innerHTML = `<div style="display:grid; grid-template-columns:repeat(4,1fr); gap:10px;">
      ${HYPER_DECK.map(master => {
        const isFound = this.game ? this.game.record.data.collectedCardIds.includes(master.id) : false;
        return `<div class="mini-ref-wrapper ${isFound ? 'collected' : 'missing'}">${this.createSampleCard(master.id)}</div>`;
      }).join('')}
    </div>`;
  }
  renderRuleTab() {
    document.getElementById('tab-rule').innerHTML = `
      <div style="text-align: left; padding: 5px 15px 40px 15px; color: #f0e68c; font-size: 0.85rem; line-height: 1.7;">
      <h3 style="color:#ffa700; border-bottom:1px solid #ffa700;">âš”ï¸ æ¥µï¼š3å›æˆ¦ãƒãƒƒãƒåˆ¶</h3>
      <p>â— <b>20ç‚¹æŒã¡</b>ã§é–‹å§‹ã—ã€3å›æˆ¦çµ‚äº†æ™‚ã®æ®‹ã‚Šç‚¹æ•°ã‚’ç«¶ã„ã¾ã™ã€‚<br>â— ç›¸æ‰‹ã®ç‚¹ã‚’<b>0ç‚¹</b>ã«ã™ã‚Œã°ã€ãã®æ™‚ç‚¹ã§å®Œå…¨å‹åˆ©ã¨ãªã‚Šã¾ã™ã€‚</p>
      
      <h3 style="color:#cda869; border-bottom:1px solid #cda869; margin-top:20px;">æ¥µã®åŸºæœ¬ï¼š2ã‚¹ãƒ†ãƒƒãƒ—åˆ¶</h3>
      <p>1.ğŸ–ï¸<b>æ‰‹æœ­ã‚’å‡ºã™</b> â” 2.<b>å±±æœ­ã‚’ã‚ãã‚‹</b><br>ã“ã®å„€å¼ãŒå®Œäº†ã—ã¦1ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚é»„é‡‘ã«å…‰ã‚‹ã‚¬ã‚¤ãƒ‰ã«å¾“ã£ã¦ãã ã•ã„ã€‚</p>
      
      <h3 style="color:#cda869; border-bottom:1px solid #cda869; margin-top:20px;">ğŸ† ä¸»è¦ãªå½¹ã¨çµµæœ­</h3>
      <div style="margin-bottom:15px; background:rgba(255,255,255,0.05); padding:10px; border-radius:4px; border:1px solid rgba(205,168,105,0.2);">
      <p style="font-weight:bold; margin-bottom:5px;">â— äº”å…‰ (20æ–‡)</p>
      <div style="display:flex; gap:5px; margin-bottom:10px; flex-wrap:wrap;">${['m01-h', 'm03-h', 'm08-h', 'm11-h', 'm12-h'].map(id=>this.createSampleCard(id)).join('')}</div>
      <p style="font-weight:bold; margin-bottom:5px;">â— çŒªé¹¿è¶ (10æ–‡)</p>
      <div style="display:flex; gap:5px; margin-bottom:10px; flex-wrap:wrap;">${['m07-n', 'm10-n', 'm06-n'].map(id=>this.createSampleCard(id)).join('')}</div>
      <p style="font-weight:bold; margin-bottom:5px;">â— èµ¤çŸ­ãƒ»é’çŸ­ (å„7æ–‡)</p>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <div style="display:flex; gap:3px;">${['m01-t', 'm02-t', 'm03-t'].map(id=>this.createSampleCard(id)).join('')}</div>
      <div style="display:flex; gap:3px;">${['m06-t', 'm09-t', 'm10-t'].map(id=>this.createSampleCard(id)).join('')}</div>
      </div>
      </div>
      
      <h3 style="color:#cda869; border-bottom:1px solid #cda869; margin-top:20px;">ğŸ’ é€šå¸¸ãƒ«ãƒ¼ãƒ«ã¨ã®é•ã„</h3>
      <ul style="padding-left:15px; margin-bottom:20px;">
      <li><b>ç²¾é‹­24æšæˆ¦:</b> ã‚«ã‚¹æœ­ï¼ˆ0ç‚¹ï¼‰ãªã—ã€‚æ¯ã‚¿ãƒ¼ãƒ³ãŒå‹è² ã§ã™ã€‚</li>
      <li><b>3æšã§å½¹æˆç«‹:</b> ã‚¿ãƒã‚„çŸ­å†Šã¯é€šå¸¸ã‚ˆã‚Šå°‘ãªã„ã€Œ3æšã€ã§1æ–‡ã«ãªã‚Šã¾ã™ã€‚</li>
      <li><b>å€è¿”ã—ã®ç½ :</b> ã€Œã“ã„ã“ã„ã€ä¸­ã«ç›¸æ‰‹ã«ä¸ŠãŒã‚‰ã‚Œã‚‹ã¨å¤±ç‚¹ãŒ<b>2å€</b>ã«ãªã‚Šã¾ã™ã€‚</li>
      <li><b>ç›´æ„Ÿæ“ä½œ:</b> æ‰‹æœ­ã‚’ã‚¿ãƒƒãƒ—ã§é¸æŠã€‚<b>ã‚‚ã†ä¸€åº¦åŒã˜æ‰‹æœ­</b>ã‹ã€<b>å…‰ã£ãŸå ´æœ­</b>ã‚’ã‚¿ãƒƒãƒ—ã§æ±ºå®šã§ã™ã€‚</li>
      </ul>
      </div>`;
  }
}

class GameController {
  constructor() {
    this.judge = new HyperJudge(); this.record = new RecordManager(); this.sync = new StatusSyncManager(this);
    this.ui = {
      game: document.getElementById('game-container'), cardLayer: document.getElementById('card-layer'), topUiArea: document.getElementById('top-ui-area'),
      pScore: document.getElementById('player-score'), oScore: document.getElementById('opponent-score'),
      deckCount: document.getElementById('deck-count'), deck: document.getElementById('deck'), log: document.getElementById('system-log'),
      overlay: document.getElementById('decision-overlay'), owner: document.getElementById('celebration-owner'), role: document.getElementById('celebration-role-name'),
      slot: document.getElementById('slot-score-display'), btns: document.getElementById('role-decision-buttons'), reset: document.getElementById('reset-btn'),
      notification: document.getElementById('role-completion-notification')
    };
    this.isProcessing = false; this.state = 'IDLE'; this.focusedCard = null; this.init();
  }

  async executeAction(actionName, actionFunc) {
    if (this.isProcessing) return;
    this.isProcessing = true; this.updateUIState();
    try { await actionFunc(); } catch (e) { console.error(e); this.switchTurn(true); }
    finally { this.isProcessing = false; this.updateUIState(); }
  }

  updateUIState() {
    const container = this.ui.game;
    if (this.isProcessing || this.state === 'OPPONENT_TURN') {
      container.classList.add('ui-locked'); container.classList.remove('waiting-input');
    } else {
      container.classList.remove('ui-locked');
      if (this.state === 'PLAYER_TURN' || this.state === 'WAIT_DECK' || this.state === 'WAIT_ACQUISITION') {
        container.classList.add('waiting-input');
      } else {
        container.classList.remove('waiting-input');
      }
    }
    let navStep = 'NONE';
    if (this.state === 'PLAYER_TURN') navStep = 'HAND'; else if (this.state === 'WAIT_DECK') navStep = 'DECK';
    this.updateNavigation(navStep);
  }

  init() { document.body.classList.add('is-opening'); this.initNavigationUI(); this.prepareTop(); this.bindEvents(); this.sync.sync(); }

  initNavigationUI() {
    const navDiv = document.createElement('div'); navDiv.id = 'step-navigator';
    navDiv.style.cssText = `display: flex; gap: 15px; background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 20px; border: 1px solid #4a3a2a; font-size: 0.8rem; font-weight: bold; white-space: nowrap; box-shadow: 0 4px 6px rgba(0,0,0,0.5);`;
    navDiv.innerHTML = `
      <span id="nav-step1" style="color: #666;">1. ğŸ–ï¸ æ‰‹æœ­ã‚’å‡ºã™</span><span style="color: #444;">â–¶</span>
      <span id="nav-step2" style="color: #666;">2. ğŸ´ å±±æœ­ã‚’ã‚ãã‚‹</span><span id="nav-koikoi-warn" style="display:none; color:#ff3333; margin-left:10px; animation:blink 1s infinite;">âš ï¸ å€è¿”ã—ä¸­</span>`;
    document.getElementById('nav-area').appendChild(navDiv);
  }

  updateNavigation(step) {
    const s1 = document.getElementById('nav-step1'), s2 = document.getElementById('nav-step2'), warn = document.getElementById('nav-koikoi-warn');
    if (!s1 || !s2) return;
    s1.style.color = (step === 'HAND') ? '#ffa700' : '#666'; s1.style.textShadow = (step === 'HAND') ? '0 0 8px #ffa700' : 'none';
    s2.style.color = (step === 'DECK') ? '#ffa700' : '#666'; s2.style.textShadow = (step === 'DECK') ? '0 0 8px #ffa700' : 'none';
    if (warn) warn.style.display = (this.playerKoikoiCount > 0 || this.opponentKoikoiCount > 0) ? 'inline' : 'none';
  }

  updatePlayableHints() {
    this.playerHand.forEach(c => c.element.classList.remove('playable-hint'));
    if (this.state === 'PLAYER_TURN' && !this.isProcessing) {
      this.playerHand.forEach(h => {
        if (this.field.some(f => f.month === h.month)) h.element.classList.add('playable-hint');
      });
    }
  }

  setState(newState) {
    this.state = newState;
    if (newState === 'PLAYER_TURN') {
      this.updatePlayableHints();
      const hasPlayable = this.playerHand.some(h => this.field.some(f => f.month === h.month));
      if (hasPlayable) {
        this.ui.log.innerHTML = `âœ¨ å…‰ã‚‹æ‰‹æœ­ã‚’å‡ºã—ã¦ç²å¾—ã—ã¦ãã ã•ã„`;
      } else {
        this.ui.log.innerHTML = `ğŸ‚ å–ã‚Œã‚‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ¨ã¦ã‚‹æ‰‹æœ­ã‚’2å›ã‚¿ãƒƒãƒ—ã—ã¦å‡ºã—ã¦ãã ã•ã„`;
      }
    }
    else if (newState === 'WAIT_DECK') {
      this.ui.log.innerText = "å±±æœ­ã‚’ã‚ãã£ã¦ãã ã•ã„";
      this.playerHand.forEach(c => c.element.classList.remove('playable-hint'));
    }
    else if (newState === 'OPPONENT_TURN') {
      this.ui.log.innerHTML = `ğŸ¤– ã‚ã„ã¦ãŒè€ƒæ¡ˆä¸­...`;
    }
    this.updateUIState();
  }

  switchTurn(isPlayer) { document.body.classList.remove('turn-opponent'); this.setState(isPlayer ? 'PLAYER_TURN' : 'OPPONENT_TURN'); if(isPlayer) this.checkEnd(); }
  sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  prepareTop() {
    document.getElementById('top-rank-display').innerText = this.record.getRank();
    document.getElementById('top-collection-display').innerText = `${this.record.getCollectionRate()} / 24 æš`;
    
    this.startGoldParticleEffect();
    
    document.getElementById('start-btn').onclick = () => {
      document.body.classList.remove('is-opening');
      document.getElementById('top-ui-area').style.display = 'none';
      this.stopGoldParticleEffect();
      this.start(); 
    };
  }

  startGoldParticleEffect() {
    const container = document.querySelector('.top-background-effect');
    if (!container) return;
    this.particleInterval = setInterval(() => {
      const p = document.createElement('div');
      p.className = 'gold-particle-fall';
      p.style.left = Math.random() * 100 + '%';
      p.style.animationDuration = (5 + Math.random() * 5) + 's';
      p.style.opacity = Math.random();
      container.appendChild(p);
      setTimeout(() => p.remove(), 10000);
    }, 500);
  }

  stopGoldParticleEffect() {
    if (this.particleInterval) {
      clearInterval(this.particleInterval);
      const container = document.querySelector('.top-background-effect');
      if (container) container.innerHTML = ''; 
    }
  }

  async start() {
    if (this.state === 'IDLE' || this.currentRound > 3 || this.matchPointsP <= 0 || this.matchPointsO <= 0) {
      this.currentRound = 1;
      this.matchPointsP = 20; 
      this.matchPointsO = 20;
    }
    this.deck = [...HYPER_DECK].sort(() => Math.random() - 0.5);
    this.playerHand = []; this.opponentHand = []; this.field = []; this.playerCollected = []; this.opponentCollected = [];
    this.playerKoikoiCount = 0; this.opponentKoikoiCount = 0; this.isProcessing = false; this.focusedCard = null;
    this.ui.reset.classList.remove('hidden'); 
    this.ui.log.innerHTML = `ğŸ´ ç¬¬ ${this.currentRound} å›æˆ¦ï¼šæœ­ã‚’é…ã£ã¦ã„ã¾ã™...`;
    await this.deal();
    const initialResult = this.checkInitialHand(this.playerHand);
    if(initialResult) return this.forceDraw(initialResult);
    this.sync.sync(); this.switchTurn(true);
  }

  startNextRound() {
    this.ui.cardLayer.innerHTML = '';
    this.ui.overlay.innerHTML = ''; this.ui.overlay.classList.add('hidden');
    document.body.classList.remove('overlay-active'); this.ui.game.classList.remove('celebration-mode');
    this.ui.notification.classList.add('hidden'); this.ui.overlay.appendChild(this.ui.notification);
    this.start();
  }

  async deal() {
    this.updateDeck();
    
    // å±±æœ­ã®ç¾åœ¨ä½ç½®ã‚’å–å¾—ï¼ˆã“ã“ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ãŒé£›ã‚“ã§ã„ãã‚ˆã†ã«ã™ã‚‹ï¼‰
    const deckRect = this.ui.deck.getBoundingClientRect(); 
    const cRect = this.ui.game.getBoundingClientRect();
    const startX = deckRect.left - cRect.left + deckRect.width / 2;
    const startY = deckRect.top - cRect.top + deckRect.height / 2;

    // ã‚«ãƒ¼ãƒ‰ç”Ÿæˆæ™‚ã«ã€Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ã€ã§ä¸€æ—¦å±±æœ­ã®ä½ç½®ã«éš ã™å‡¦ç†
    const setupInitialPosition = (el) => {
      el.style.transition = 'none';
      el.style.left = `${startX}px`;
      el.style.top = `${startY}px`;
      el.style.transform = `translate(-50%, -50%) scale(0.5)`;
      void el.offsetHeight; // ãƒ–ãƒ©ã‚¦ã‚¶ã«åˆæœŸä½ç½®ã‚’å¼·åˆ¶èªè­˜ã•ã›ã‚‹
      el.style.transition = ''; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’å…ƒã«æˆ»ã™
    };

    // 1. ã¾ãšã€Œå ´ã€ã«4æšã‚’å°‘ã—ãšã¤é…ã‚‹
    for (let i = 0; i < 4; i++) { 
      const data = this.deck.pop(); 
      const el = this.createCardUI(data);
      setupInitialPosition(el);
      this.field.push({ ...data, element: el }); 
      this.renderCards();
      this.updateDeck();
      await this.sleep(150);
    }

    // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚ã„ã¦ã«ã€Œäº¤äº’ã«5æšãšã¤ã€é…ã‚‹ï¼ˆå±±æœ­10æšã¨ã´ã£ãŸã‚Šä¸€è‡´ã•ã›ã‚‹ï¼‰
    for (let i = 0; i < 5; i++) {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­
      const pData = this.deck.pop(); 
      const pObj = { ...pData, element: this.createCardUI(pData) };
      setupInitialPosition(pObj.element);
      pObj.element.onclick = (e) => {
        e.stopPropagation();
        if (this.state !== 'PLAYER_TURN' || document.body.classList.contains('turn-opponent') || this.isProcessing) return;
        if (!this.playerHand.includes(pObj)) return;

        if (this.focusedCard === pObj) {
          this.executeAction('Player Hand', async () => { this.clearFocus(); await this.handleHandAction(pObj, true); });
        } else {
          this.clearFocus(); this.focusedCard = pObj; pObj.element.classList.add('focused'); this.highlightMatches(pObj);
        }
      };
      this.playerHand.push(pObj);
      this.renderCards();
      this.updateDeck();
      await this.sleep(100);

      // ã‚ã„ã¦ã®æ‰‹æœ­
      const oData = this.deck.pop();
      const oEl = this.createCardUI(oData); 
      oEl.classList.add('role-opponent');
      setupInitialPosition(oEl);
      this.opponentHand.push({ ...oData, element: oEl });
      this.renderCards();
      this.updateDeck();
      await this.sleep(100);
    }
    
    await this.sleep(500); // å…¨ã¦é…ã‚Šçµ‚ãˆã¦ã‚²ãƒ¼ãƒ ãŒå§‹ã¾ã‚‹ç›´å‰ã®ä½™éŸ»
  }

  createCardUI(data) {
    const div = document.createElement('div');
    const tagClasses = data.tags ? data.tags.join(' ') : '';
    let tanzakuClass = '';
    if (data.type === 'tanzaku') { if (data.tags.includes('akatan')) tanzakuClass = 'akatan'; else if (data.tags.includes('aotan')) tanzakuClass = 'aotan'; }
    div.className = `card month-${data.month} ${data.type} ${tagClasses} ${tanzakuClass}`;
    div.innerHTML = `
<div class="card-month-number">${data.month}</div>
<div class="card-inner-art"><span class="emoji-main">${data.symbol}</span></div>
`;
    this.ui.cardLayer.appendChild(div);
    return div;
  }

  renderCards() {
    this.updateCardPositions(this.playerHand, 'player-hand', 'player');
    this.updateCardPositions(this.opponentHand, 'opponent-hand', 'opponent');
    this.updateCardPositions(this.field, 'field-cards-container', 'field');
    this.updatePairedPositions(this.playerCollected, 'player-paired');
    this.updatePairedPositions(this.opponentCollected, 'opponent-paired');
  }

  // --- å ´æœ­ãŒé‡ãªã‚Šã™ããªã„ã‚ˆã†ã€è‡ªå‹•çš„ã«ã€Œä¸Šä¸‹2æ®µã€ã«æ•´åˆ—ã•ã›ã‚‹ ---
  updateCardPositions(cards, targetId, role) {
    if (!cards || cards.length === 0) return;
    const target = document.getElementById(targetId); if (!target) return;
    const rect = target.getBoundingClientRect(); const cRect = this.ui.game.getBoundingClientRect();
    const width = rect.width; 
    const baseY = rect.top - cRect.top;

    cards.forEach((card, i) => {
      const el = card.element;
      if (el.classList.contains('capture-flash')) return;

      let tLeft, tTop, tTransform;

      if (role !== 'field') {
        const spacing = Math.min(50, width / (cards.length + 1));
        const startX = rect.left - cRect.left + (width - (spacing * (cards.length - 1))) / 2;
        tLeft = `${startX + (i * spacing)}px`;

        if (role === 'player') {
          tTop = `${baseY + rect.height - 90}px`;
          tTransform = `translateX(-50%) rotate(${(i - (cards.length-1)/2)*5}deg)`;
        } else if (role === 'opponent') {
          tTop = `${baseY + 5}px`;
          tTransform = `translateX(-50%) rotate(${-(i - (cards.length-1)/2)*4}deg)`;
        } else {
          tTop = `${baseY + rect.height/2}px`;
          tTransform = `translate(-50%, -50%)`;
        }
      } else {
        // å±±æœ­ã‚’é¿ã‘ã¤ã¤ã€ä¸Šä¸‹2æ®µã«åˆ†ã‘ã¦é…ç½®
        const cols = Math.max(1, Math.ceil(cards.length / 2));
        const fieldSpacing = Math.min(80, (width - 100) / cols);
        const fieldStartX = rect.left - cRect.left + (width - 100 - (fieldSpacing * (cols - 1))) / 2;

        const col = i % cols;
        const row = Math.floor(i / cols);

        tLeft = `${fieldStartX + (col * fieldSpacing)}px`;
        tTop = `${baseY + rect.height / 2 + (row === 0 ? -45 : 45)}px`;
        tTransform = `translate(-50%, -50%)`;
      }

      el.style.left = tLeft;
      el.style.top = tTop;

      if (!el.classList.contains('focused') && !el.classList.contains('match-highlight')) {
        el.style.transform = tTransform;
        el.style.zIndex = 100 + i;
      }
    });
  }

  updatePairedPositions(cards, targetId) {
    if (!cards || cards.length === 0) return;
    const target = document.getElementById(targetId); if (!target) return;
    const rect = target.getBoundingClientRect(); const cRect = this.ui.game.getBoundingClientRect();
    const baseY = rect.top - cRect.top; const baseX = rect.left - cRect.left;

    // æœ­ã®ç¨®é¡ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã‘ã—ã¦æ•´ç†ã™ã‚‹
    const groups = { 'hikari': [], 'tane': [], 'tanzaku': [], 'other': [] };
    cards.forEach(card => {
      if (groups[card.type]) groups[card.type].push(card);
      else groups['other'].push(card);
    });

    // ç¨®é¡ã”ã¨ã®ç¸¦ã®é…ç½®ï¼ˆæ®µï¼‰ã‚’è¨­å®š
    const yOffsets = { 'hikari': 0, 'tane': 30, 'tanzaku': 60, 'other': 90 };

    // ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«æç”»
    Object.keys(groups).forEach(type => {
      groups[type].forEach((card, index) => {
        const el = card.element;
        if (el.classList.contains('capture-flash')) return;

        // åŒã˜ç¨®é¡ã®ä¸­ã§æ¨ªã«å°‘ã—ãšã¤ã‚ºãƒ©ã™
        const xOffset = index * 25;
        const yOffset = yOffsets[type];

        el.style.left = `${baseX + 30 + xOffset}px`;
        el.style.top = `${baseY + 15 + yOffset}px`;
        el.style.zIndex = index + (type === 'hikari' ? 100 : type === 'tane' ? 50 : 0); 
        el.style.transform = `translateX(-50%) scale(0.7)`;
      });
    });
  }

  clearFocus() {
    this.focusedCard = null;
    this.playerHand.forEach(c => c.element.classList.remove('focused'));
    this.clearHighlights();
    this.renderCards();
  }

  async executeOpponentTurn() {
    if (this.state !== 'OPPONENT_TURN') return;
    this.executeAction('AI Turn', async () => {
      document.body.classList.add('turn-opponent');
      await this.aiThinkAndAct();
    }).finally(() => { if (this.state !== 'DECISION' && this.state !== 'END') { setTimeout(() => this.switchTurn(true), 500); } });
  }

  async aiThinkAndAct() {
    await this.sleep(1200);
    let card = this.opponentHand.find(h => this.field.some(f => f.month === h.month));
    
    // ä¸€è‡´ã™ã‚‹æœ­ãŒãªã„å ´åˆã¯æ‰‹æœ­ã®1æšç›®ã‚’é¸æŠ
    if (!card && this.opponentHand.length > 0) card = this.opponentHand;
    
    if (card) {
      card.element.classList.remove('role-opponent');
      
      const match = this.field.find(f => f.month === card.month);
      if (match) {
        match.element.classList.add('match-highlight');
        this.ui.log.innerHTML = `ğŸ¤– ã‚ã„ã¦ãŒ <span style="color:#fff;">${card.month}æœˆ</span> ã‚’ç‹™ã£ã¦ã„ã¾ã™`;
        await this.sleep(800);
      } else {
        await this.sleep(800);
      }
      
      await this.handleHandAction(card, false);
    }
  }

  async processCardMatch(card, isPlayer) {
    const match = this.field.find(f => f.month === card.month);
    if (match) {
      if (isPlayer) {
        this.setState('WAIT_ACQUISITION');
        this.ui.log.innerText = "ğŸ‘† æ¿€ã—ãå…‰ã‚‹å ´æœ­ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ç²å¾—ã—ã¦ãã ã•ã„";
        match.element.classList.add('match-highlight'); card.element.classList.add('match-highlight');
        
        await new Promise(resolve => {
          let resolved = false;
          const finish = () => { if (resolved) return; resolved = true; clearTimeout(timer); resolve(); };
          match.element.onclick = (e) => { e.stopPropagation(); match.element.onclick = null; finish(); };
          const timer = setTimeout(finish, 4000);
        });
      }
      
      match.element.classList.remove('match-highlight', 'dimmed');
      card.element.classList.remove('match-highlight', 'dimmed');
      
      const cRect = this.ui.game.getBoundingClientRect();
      const centerX = cRect.width / 2; const centerY = cRect.height / 2;

      card.element.style.transition = 'all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1)';
      card.element.style.left = `${centerX}px`; card.element.style.top = `${centerY}px`;
      card.element.style.transform = `translate(-65%, -55%) scale(1.3) rotate(-5deg)`;
      card.element.style.zIndex = "2000";
      card.element.classList.add('capture-flash');

      match.element.style.transition = 'all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1)';
      match.element.style.left = `${centerX}px`; match.element.style.top = `${centerY}px`;
      match.element.style.transform = `translate(-35%, -45%) scale(1.3) rotate(5deg)`;
      match.element.style.zIndex = "1999"; 
      match.element.classList.add('capture-flash');

      if (isPlayer) this.ui.log.innerText = "âœ¨ æœ­ã‚’ç²å¾—ã—ã¾ã—ãŸ";
      
      // ãƒ†ãƒ³ãƒæ”¹å–„ï¼š1.5ç§’ã‹ã‚‰ã€Œ0.75ç§’ã€ã¸çŸ­ç¸®
      await this.sleep(750);

      [card.element, match.element].forEach(el => el.classList.remove('capture-flash'));
      
      this.field = this.field.filter(f => f !== match);
      const collected = isPlayer ? this.playerCollected : this.opponentCollected;
      collected.push(card, match);
    } else {
      if (isPlayer) this.ui.log.innerText = "ğŸ‚ æœ­ã‚’å ´ã«ç½®ãã¾ã—ãŸ";
      this.field.push(card);
    }
    this.renderCards(); await this.sleep(500);
  }

  async handleHandAction(card, isPlayer) {
    if (isPlayer) this.playerHand = this.playerHand.filter(h => h !== card);
    else this.opponentHand = this.opponentHand.filter(h => h !== card);
    await this.processCardMatch(card, isPlayer);
    if (this.deck.length > 0) {
      this.setState('WAIT_DECK'); this.ui.deck.classList.add('active-guide');
      if (!isPlayer) { await this.sleep(800); await this.handleDeckAction(false); }
    } else { await this.finalizeTurn(isPlayer); }
  }

  async handleDeckAction(isPlayer) {
    this.ui.deck.classList.remove('active-guide');
    const drawnData = this.deck.pop();
    const obj = { ...drawnData, element: this.createCardUI(drawnData) };
    const deckRect = this.ui.deck.getBoundingClientRect(); const cRect = this.ui.game.getBoundingClientRect();
    obj.element.style.left = `${deckRect.left - cRect.left + 20}px`; obj.element.style.top = `${deckRect.top - cRect.top + 30}px`;
    await this.sleep(50);
    const fieldRect = document.getElementById('field-cards-container').getBoundingClientRect();
    obj.element.style.left = `${fieldRect.left - cRect.left + fieldRect.width/2}px`;
    obj.element.style.top = `${fieldRect.top - cRect.top + fieldRect.height/2}px`;
    obj.element.style.transform = `translate(-50%, -50%) scale(1.1)`; obj.element.style.zIndex = 1000;
    await this.sleep(1000);
    obj.element.style.transform = `translate(-50%, -50%) scale(1)`;
    await this.processCardMatch(obj, isPlayer);
    this.updateDeck(); await this.finalizeTurn(isPlayer);
  }

  async finalizeTurn(isPlayer) {
    this.sync.sync(); const collected = isPlayer ? this.playerCollected : this.opponentCollected;
    const yaku = this.judge.check(collected);
    if (yaku.length > 0) { await this.showResult(yaku, isPlayer); }
    else { if (isPlayer) { this.switchTurn(false); this.executeOpponentTurn(); } }
  }

  updateDeck() { if (this.ui.deckCount) this.ui.deckCount.innerText = this.deck.length; }
  calculateCurrentPoints(cards) { return this.judge.check(cards).reduce((sum, y) => sum + y.points, 0); }

  highlightMatches(sc) {
    this.clearHighlights(); if (!sc) return; let hasMatch = false;
    this.field.forEach(f => {
      if(f.month === sc.month) { f.element.classList.add('match-highlight'); hasMatch = true; }
      else { f.element.classList.add('dimmed'); }
    });
    if(!hasMatch) this.field.forEach(f => f.element.classList.remove('dimmed'));
  }

  clearHighlights() { this.field.forEach(f => { f.element.classList.remove('match-highlight'); f.element.classList.remove('dimmed'); }); }

  checkInitialHand(hand) {
    const counts = {}; hand.forEach(c => counts[c.month] = (counts[c.month] || 0) + 1);
    if (Object.values(counts).some(v => v === 4)) return "æ‰‹å››"; if (Object.values(counts).filter(v => v === 2).length === 3) return "ãã£ã¤ã";
    return null;
  }

  async showResult(yaku, isPlayer) {
    this.setState('DECISION'); const latestYaku = yaku[yaku.length - 1];
    if (latestYaku.name === "äº”å…‰") await this.triggerDivineEffect(); else if (latestYaku.name === "çŒªé¹¿è¶") this.createButterflies();
    this.ui.game.classList.add('celebration-mode'); this.createGoldLeaf();
    this.ui.owner.innerText = isPlayer ? "ğŸ˜¯ ã‚ãªãŸã®å½¹" : "ğŸ¤– ã‚ã„ã¦ã®å½¹";
    
    const phraseMap = {
      "äº”å…‰": "ã€Œå¤©åœ°ã‚’çµ±ã¹ã‚‹ã€äº”ã¤ã®è‡³å®ã€",
      "çŒªé¹¿è¶": "ã€Œä¹±ä¸–ã‚’èˆã†ã€ç”Ÿå‘½ã®è¼ªèˆæ›²ã€",
      "èŠ±è¦‹é…’": "ã€Œç™¾èŠ±ç¹šä¹±ã€å®´ã®å¹•é–‹ã‘ã€",
      "æœˆè¦‹é…’": "ã€Œæœˆä¸‹ç‹¬é…Œã€é»„é‡‘ã®é›«ã€",
      "ä¸‰å…‰": "ã€Œä¸‰ç•Œã‚’ç…§ã‚‰ã™ã€å¸Œæœ›ã®å…‰ã€"
    };
    const phrase = phraseMap[latestYaku.name] || "ã€Œé‹å‘½ãŒã€ä»Šå‹•ãå‡ºã™ã€";
    
    this.ui.role.innerHTML = `<div style="font-size: 1.1rem; font-style: italic; color: #fff7ad; margin-bottom: 8px;">${phrase}</div><div style="letter-spacing: 0.3rem;">âœ¨ ${latestYaku.name} âœ¨</div>`;
    
    this.ui.overlay.classList.remove('hidden'); this.ui.notification.classList.remove('hidden');
    this.ui.btns.classList.remove('hidden'); this.ui.slot.classList.add('hidden'); this.ui.reset.classList.add('hidden');
    if (!isPlayer) { setTimeout(() => { this.executeAction('AI Decision', async () => { this.handleAIDecision(yaku); }); }, 2500); }
  }

  handleAIDecision(yaku) {
    const shouldKoikoi = this.deck.length > 3 && Math.random() > 0.5;
    if (shouldKoikoi) {
      this.opponentKoikoiCount++; this.ui.log.innerText = "ğŸ¤– ã‚ã„ã¦ï¼šã“ã„ã“ã„ï¼";
      this.ui.game.classList.remove('celebration-mode'); this.ui.overlay.classList.add('hidden'); this.ui.notification.classList.add('hidden');
      this.switchTurn(true);
    } else { this.triggerWin(false, yaku); }
  }

  triggerWin(isPlayer, yaku) {
    const totalPoints = yaku.reduce((sum, y) => sum + y.points, 0); const latestYakuName = yaku[yaku.length - 1].name;
    this.ui.notification.classList.remove('hidden'); this.ui.btns.classList.add('hidden');
    this.ui.slot.classList.remove('hidden'); this.ui.overlay.classList.remove('hidden');
    let current = 0; const step = Math.ceil(totalPoints / 20) || 1;
    const timer = setInterval(() => {
      current += step;
      if (current >= totalPoints) { current = totalPoints; clearInterval(timer); this.finalizeScore(isPlayer ? 'player' : 'opponent', totalPoints, latestYakuName); }
      this.ui.slot.innerText = current;
    }, 50);
  }

  finalizeScore(winner, basePoints, yakuName = "å½¹") {
    document.body.classList.add('overlay-active'); this.ui.overlay.classList.remove('hidden'); this.ui.notification.classList.add('hidden');
    let finalPoints = basePoints; let multiplierText = "";
    if (winner !== null) {
      const isPlayerWin = winner === 'player';
      if ((isPlayerWin && this.opponentKoikoiCount > 0) || (!isPlayerWin && this.playerKoikoiCount > 0)) {
        finalPoints *= 2;
        multiplierText = "<br><span style='color:#ff3333; font-size:0.8em; animation:blink 1s infinite;'>âš ï¸ å€è¿”ã—ï¼</span>";
      }
      if (isPlayerWin) {
        this.matchPointsO -= finalPoints;
        this.record.update(finalPoints, true);
        this.record.updateCollection(this.playerCollected);
      } else {
        this.matchPointsP -= finalPoints;
        this.record.update(0, false);
      }
    }
    this.currentRound++;
    const isMatchEnd = (this.currentRound > 3 || this.matchPointsP <= 0 || this.matchPointsO <= 0);
    const winnerText = isMatchEnd ? "ğŸ‘‘ ãƒãƒƒãƒçµ‚äº† ğŸ‘‘" : (winner === 'player' ? "ğŸ‰ ã‚ãªãŸã®å‹ã¡ ğŸ‰" : winner === 'opponent' ? "ğŸ¤– ã‚ã„ã¦ã®å‹ã¡ ğŸ¤–" : "ğŸ‚ å‹è² ãªã— ğŸ‚");
    
    this.ui.overlay.innerHTML = `
      <div class="modal-box" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000;">
      <h2 style="color: #cda869;">${winnerText}</h2>
      <div style="font-size: 1.5rem; margin-bottom: 20px;">${yakuName} : ${finalPoints} æ–‡ ${multiplierText}</div>
      <button id="next-round-btn" class="btn-gold">${isMatchEnd ? 'æœ€çµ‚çµæœã¸' : 'æ¬¡ã®å›æˆ¦ã¸'}</button>
      </div>`;
      
    document.getElementById('next-round-btn').onclick = () => {
      if (isMatchEnd) this.showFinalMatchResult();
      else this.startNextRound();
    };
    this.setState('END');
    this.sync.sync();
  }

  showFinalMatchResult() {
    const isPlayerVictory = this.matchPointsP > this.matchPointsO;
    const diff = Math.abs(this.matchPointsP - this.matchPointsO);
    const title = isPlayerVictory ? "ğŸ‘‘ å®Œå…¨å‹åˆ© ğŸ‘‘" : "ğŸ‚ æ•—åŒ— ğŸ‚";
    const subTitle = isPlayerVictory ? `ã‚ã„ã¦ã‚’ ${diff} ç‚¹å·®ã§åœ§å€’ã—ã¾ã—ãŸ` : `ã‚ãªãŸã¯ ${diff} ç‚¹å·®ã§æ•—ã‚Œã¾ã—ãŸ`;
    this.ui.overlay.innerHTML = `
      <div class="modal-box" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000;">
      <h1 style="color: #ffa700; font-size: 2.5rem; margin-bottom: 10px;">${title}</h1>
      <p style="color: #f0e68c; margin-bottom: 30px;">${subTitle}</p>
      <button id="restart-match-btn" class="btn-gold" style="padding: 15px 40px; font-size: 1.2rem;">æ–°ã—ã„ãƒãƒƒãƒã‚’å§‹ã‚ã‚‹</button>
      </div>`;
    document.getElementById('restart-match-btn').onclick = () => {
      this.currentRound = 1; this.matchPointsP = 20; this.matchPointsO = 20;
      this.startNextRound();
    };
  }

  checkEnd() { if (this.playerHand.length === 0 && this.opponentHand.length === 0) { this.finalizeScore(null, 0, "æµå±€ï¼ˆå¼•ãåˆ†ã‘ï¼‰"); } }

  forceDraw(reason) {
    this.setState('END'); document.body.classList.add('overlay-active'); this.ui.overlay.classList.remove('hidden');
    this.ui.overlay.innerHTML = `
      <div class="modal-box silver" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000;">
      <h2 style="color: #aaa; margin-bottom: 15px;">ğŸ´ ç‰¹æ®Šæµå±€</h2><div style="font-size: 1.2rem; margin-bottom: 25px;">${reason} ã«ã‚ˆã‚Šå†è©¦åˆ</div>
      <button id="next-round-btn" class="btn-gold" style="padding: 10px 30px; font-size: 1.2rem;">æ¬¡ã®å±€ã¸é€²ã‚€</button>
      </div>`;
    document.getElementById('next-round-btn').onclick = () => this.startNextRound();
  }

  bindEvents() {
    document.addEventListener('contextmenu', e => e.preventDefault());
    
    this.ui.reset.onclick = () => { if (this.state === 'END' || confirm("å¯¾å±€ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) location.reload(); };
    document.getElementById('roles-btn').onclick = () => { this.sync.showEncyclopedia(); };
    document.getElementById('role-win-btn').onclick = () => this.triggerWin(true, this.judge.check(this.playerCollected));
    document.getElementById('role-koikoi-btn').onclick = () => {
      this.playerKoikoiCount++; this.ui.overlay.classList.add('hidden'); this.ui.notification.classList.add('hidden'); this.ui.game.classList.remove('celebration-mode');
      this.switchTurn(false); this.executeOpponentTurn();
    };
    
    // å±±æœ­ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ä»–ã®ã‚¿ãƒƒãƒ—åˆ¤å®šã¸ã®å¹²æ¸‰ã‚’é˜²ã
    this.ui.deck.onclick = (e) => {
      e.stopPropagation();
      if (this.state === 'WAIT_DECK' && !this.isProcessing) {
        this.executeAction('Player Draw Deck', async () => { await this.handleDeckAction(true); });
      }
    };
    
    this.ui.game.onclick = (e) => {
      const cardEl = e.target.closest('.card');
      if (cardEl) {
        if (cardEl.classList.contains('match-highlight') && this.focusedCard) {
          const targetCard = this.focusedCard;
          this.executeAction('Player Hand', async () => { this.clearFocus(); await this.handleHandAction(targetCard, true); });
        }
      } else {
        if (this.focusedCard) this.clearFocus();
      }
    };
  }

  async triggerDivineEffect() {
    const flash = document.createElement('div'); flash.className = 'divine-flash-overlay'; document.body.appendChild(flash);
    setTimeout(() => flash.classList.add('active'), 10); document.querySelectorAll('.card').forEach(c => c.classList.add('divine-fade-out'));
    await this.sleep(600); flash.classList.remove('active'); setTimeout(() => { flash.remove(); document.querySelectorAll('.card').forEach(c => c.classList.remove('divine-fade-out')); }, 1000);
  }

  createGoldLeaf() {
    for (let i = 0; i < 50; i++) {
      const leaf = document.createElement('div'); leaf.className = 'gold-particle';
      const duration = 2 + Math.random() * 3, delay = Math.random() * 2;
      leaf.style.left = Math.random() * 100 + 'vw'; leaf.style.width = (6 + Math.random() * 8) + 'px'; leaf.style.height = leaf.style.width;
      leaf.style.animation = `fall ${duration}s linear ${delay}s forwards`; document.body.appendChild(leaf); setTimeout(() => leaf.remove(), (duration + delay) * 1000);
    }
  }

  createButterflies() {
    for (let i = 0; i < 20; i++) {
      const b = document.createElement('div'); b.className = 'butterfly-particle'; b.innerText = 'ğŸ¦‹'; b.style.left = '50vw'; b.style.top = '50vh';
      const angle = Math.random() * Math.PI * 2, dist = 30 + Math.random() * 50;
      b.style.setProperty('--tx', (Math.cos(angle) * dist) + 'vw'); b.style.setProperty('--ty', (Math.sin(angle) * dist) + 'vh');
      b.style.animation = `butterfly-fly ${2 + Math.random() * 2}s ease-out forwards`; document.body.appendChild(b); setTimeout(() => b.remove(), 4000);
    }
  }
}

new GameController();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ã“ã„ã“ã„ï¼šæ¥µ</title>

<style>
/* =========================================
   1. æ¼†é»’ã®å¥¥è¡Œãã¨æœ¬é‡‘ç®”ã®åŸºèª¿
========================================= */
:root {
  --urushi-black: radial-gradient(ellipse at center, #1a0a0a 0%, #050202 100%);
  --gold-leaf: linear-gradient(135deg, #fff7ad 0%, #ffa700 50%, #b38b00 100%);
  --card-radius: 6px;
}

body {
  background: var(--urushi-black);
  color: #cda869;
  font-family: "Sawarabi Mincho", serif;
  margin: 0;
  overflow: hidden;
}

/* =========================================
   ã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°åˆ¶å¾¡ (DOMã‚’å£Šã•ãªã„è¡¨ç¤ºåˆ‡æ›¿)
========================================= */
body.is-opening header,
body.is-opening .message-section,
body.is-opening #opponent-section,
body.is-opening #deck,
body.is-opening #field-cards,
body.is-opening .hand-container,
body.is-opening .bottom-controls {
  display: none !important;
}

body.is-opening #field-cards-container {
  border: none;
  box-shadow: none;
  background: transparent;
  margin-top: 10vh;
}
body.is-opening #field-cards-container::before {
  display: none;
}

/* =========================================
   ç¥ç¥­æ¼”å‡ºï¼ˆèƒŒæ™¯ã®æ·±ç´…ã¸ã®é·ç§»ã€é‡‘ç®”ï¼‰
========================================= */
#game-container {
  transition: background 2s cubic-bezier(0.25, 1, 0.5, 1);
  min-height: 100vh;
  position: relative;
  overflow: hidden; max-width: 100vw;
}
#game-container.celebration-mode {
  background: radial-gradient(circle, #4d0000 0%, #1a0000 100%) !important;
}

.gold-particle {
  position: fixed; width: 10px; height: 10px;
  background: var(--gold-leaf); pointer-events: none;
  z-index: 4000; opacity: 0.8; box-shadow: 0 0 5px gold;
}
@keyframes fall {
  0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
  100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
}

#celebration-role-name {
  font-size: 2.5rem; color: #ffa700;
  text-shadow: 0 0 30px #ffa700, 0 0 50px gold;
  animation: text-pulse 1s infinite alternate;
  margin-bottom: 20px;
}
@keyframes text-pulse {
  from { transform: scale(1); }
  to { transform: scale(1.1); }
}

#slot-score-display {
  font-size: 5rem; font-weight: bold; color: #ffa700;
  text-shadow: 0 0 20px gold; margin: 15px 0;
}

/* å›ºæœ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
.divine-flash-overlay {
  position: fixed; inset: 0; background: #fff;
  z-index: 6000; opacity: 0; pointer-events: none;
  transition: opacity 0.4s ease-in-out;
}
.divine-flash-overlay.active { opacity: 1; }
.divine-fade-out { opacity: 0 !important; transition: opacity 0.5s ease-in-out; }
.yaku-divine {
  color: #fff !important;
  text-shadow: 0 0 20px #fff, 0 0 40px gold !important;
  letter-spacing: 0.8rem; transform: scale(1.2);
}

.butterfly-particle {
  position: fixed; width: 30px; height: 30px;
  font-size: 30px; pointer-events: none; z-index: 5500;
  user-select: none;
  animation: butterfly-fly 3s ease-out forwards;
}
@keyframes butterfly-fly {
  0% { transform: translate(0, 0) rotate(0deg) scale(0.5); opacity: 1; }
  100% { transform: translate(var(--tx), var(--ty)) rotate(720deg) scale(2); opacity: 0; }
}

#player-rank-display {
  color: #cda869; font-size: 1.2rem; margin-top: 10px;
  text-shadow: 0 0 10px rgba(205, 168, 105, 0.5); font-weight: bold; line-height: 1.8;
}

/* =========================================
   æœ­ã®UIå¼·åŒ–ã¨è£…é£¾
========================================= */
.card {
  width: 80px; height: 124px; flex-shrink: 0;
  background: linear-gradient(145deg, #1a0808 0%, #000 100%);
  border: 1px solid #3d2b00;
  box-shadow: inset 0 0 10px rgba(255, 167, 0, 0.1), 2px 2px 8px rgba(0,0,0,0.9);
  border-radius: var(--card-radius); position: relative;
  cursor: pointer; user-select: none;
  transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  overflow: hidden;
}
.card:hover, .card:active {
  transform: translateY(-40px) scale(1.1);
  z-index: 1000 !important;
  box-shadow: 0 15px 40px rgba(205, 168, 105, 0.5);
}

.card.match-highlight {
  box-shadow: 0 0 25px #ffa700 !important;
  transform: scale(1.1) translateY(-10px);
  z-index: 50;
}

.card-month-small { position: absolute; top: 2px; left: 4px; font-size: 0.6rem; color: #cda869; z-index: 2; }
.card-main-visual { display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; }
.card-symbol { font-size: 2.8rem; z-index: 2; filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); }
.card-label-hidden { display: none; }
.card-back { font-size: 2rem; color: #441111; display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; background: repeating-linear-gradient(45deg, #1a0000, #1a0000 10px, #2a0000 10px, #2a0000 20px); }

/* å…‰æœ­ */
.card.hikari {
  background: linear-gradient(145deg, #2a0a0a 0%, #050000 100%);
  border: 2px solid #ffa700;
  box-shadow: 0 0 15px rgba(255, 167, 0, 0.3), inset 0 0 15px rgba(255, 255, 255, 0.1);
}
.card.hikari::after { content: 'âœ¨'; position: absolute; top: -5px; right: -5px; font-size: 1.2rem; }
.card.tane { border: 1px solid #555; background: linear-gradient(145deg, #1a1a1a, #000); }

/* çŸ­å†Šæœ­ */
.card.tanzaku::before {
  content: ''; position: absolute; left: 10px; width: 10px; height: 100%;
  opacity: 0.6; z-index: 1; box-shadow: 0 0 10px rgba(255,255,255,0.5);
}
.card.akatan::before { background: linear-gradient(to bottom, #f00, #500); }
.card.aotan::before { background: linear-gradient(to bottom, #0000ff, #000080); }

/* =========================================
   2. æ¼†å¡—ã‚Šã®ç¸å–ã‚Šãƒ»é‡å±¤çš„ãªå½±
========================================= */
#opponent-section, #field-cards-container, .hand-container {
  border: none;
  box-shadow:
    inset 0 0 20px rgba(0,0,0,0.8),
    0 4px 10px rgba(0,0,0,0.6),
    0 0 0 2px #4a3a2a,
    0 0 0 3px #d4af37;
  background: rgba(20, 10, 10, 0.7);
  position: relative; margin: 15px auto; width: 95%;
  border-radius: 8px;
}

#deck {
  width: 80px; height: 124px;
  background: linear-gradient(135deg, #4b0000 0%, #1a0000 100%);
  border: 2px solid #ffa700; border-radius: 4px;
  position: relative; display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  margin: 0 auto 10px;
  box-shadow: 2px 2px 0 #300, 4px 4px 0 #200, 6px 6px 0 #100;
  cursor: pointer; transition: transform 0.2s;
}
#deck:hover { transform: translateY(-2px); }
#deck-count { position: absolute; bottom: 5px; right: 5px; font-size: 0.8rem; color: rgba(255, 167, 0, 0.6); font-weight: bold; }
.deck-visual { font-size: 2rem; }

#deck.active-guide {
  animation: deck-pulse 1.5s infinite;
  box-shadow: 0 0 20px #ffa700, 4px 4px 0 #200;
}
@keyframes deck-pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

#field-cards-container {
  display: flex; flex-wrap: wrap; gap: 10px; padding: 25px 10px; justify-content: center;
  min-height: 150px; flex-direction: column; align-items: center;
}
#field-cards-container::before {
  content: 'ğŸ´ å ´ - FIELD'; position: absolute; top: -14px; left: 20px;
  background: #050000; color: #cda869; padding: 0 10px; font-size: 0.8rem;
}
.field-cards-row { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; width: 100%; }

.hand-container, #opponent-section { padding: 10px 0; }
.hand-container::before {
  content: 'ğŸ–ï¸ ã‚ãªãŸã®æ‰‹æœ­'; position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
  background: #050000; color: #cda869; padding: 0 15px; font-size: 0.75rem;
}

.player-hand, .opponent-hand {
  display: flex; justify-content: center; padding: 25px 10px; width: 100%; height: 130px; box-sizing: border-box; overflow: visible;
}
.player-hand .card, .opponent-hand .card { margin-left: -35px; }
.player-hand .card:first-child, .opponent-hand .card:first-child { margin-left: 0; }
.player-paired { min-height: 80px; display: flex; gap: 5px; flex-wrap: wrap; padding: 10px; }

/* ç›¸æ‰‹ã®æ‰‹æœ­æƒ…å ±ã®å®Œå…¨ç§˜åŒ¿ */
.opponent-hand .card::before,
.opponent-hand .card::after,
.opponent-hand .card .card-main-visual,
.opponent-hand .card-month-small {
  display: none !important;
}

.opponent-paired {
  display: flex; justify-content: flex-start; flex-wrap: wrap; width: 90%; margin-bottom: 5px; padding: 5px;
  background: rgba(0, 0, 0, 0.3); border-radius: 8px; min-height: 40px; margin: 0 auto;
}
.opponent-paired .card {
  transform: scale(0.5) !important; filter: brightness(0.7);
  margin-left: -25px !important; margin-bottom: -40px;
}

#opponent-section { transition: background 0.5s, box-shadow 0.5s; padding: 10px; border-radius: 8px;}
#opponent-section.active { background: rgba(255, 167, 0, 0.08); box-shadow: 0 0 30px rgba(0,0,0,1) inset; }

/* é‡‘å·¥å“ã®ã‚ˆã†ãªé‡åšãªãƒœã‚¿ãƒ³ */
.btn-gold, button {
  background: linear-gradient(to bottom, #e6c370 0%, #c09830 100%);
  border: 1px solid #8a6e20;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), 0 2px 5px rgba(0,0,0,0.4);
  color: #3d2b00; text-shadow: 0 1px 0 rgba(255,255,255,0.3);
  padding: 10px 20px; font-weight: bold; border-radius: 50px; cursor: pointer; margin: 5px;
}
.btn-gold:hover, button:hover {
  background: linear-gradient(to bottom, #f7d580 0%, #d4af37 100%);
  box-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
}
button:disabled { filter: grayscale(100%); cursor: not-allowed; box-shadow: none; }

/* =========================================
   3. å½¹å›³é‘‘ã®æ¨™æœ¬ç®±ã‚¹ã‚¿ã‚¤ãƒ« (v19)
========================================= */
.role-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); backdrop-filter: blur(8px); display: flex; justify-content: center; align-items: center; z-index: 3000; }
#roles-modal-content { background: #0a0a0a; border-top: 4px solid #cda869; padding: 20px; width: 90%; max-width: 800px; border-radius: 4px; max-height: 80vh; overflow-y: auto;}
.yaku-category h3 { border-bottom: 1px solid #444; padding-bottom: 10px; font-size: 0.9rem; color: #888; text-align: center; margin-bottom: 10px;}

#hikari-list, #tane-list, #tanzaku-list {
  display: flex; flex-direction: column; gap: 10px;
}
.yaku-specimen-box {
  background: rgba(20, 10, 10, 0.8);
  border: 1px solid #cda869;
  border-radius: 6px; padding: 10px;
  box-shadow: inset 0 0 15px rgba(0,0,0,0.8);
}
.yaku-header {
  border-bottom: 1px solid rgba(205, 168, 105, 0.3); margin-bottom: 8px;
  color: #f0e68c; font-weight: bold; font-size: 0.9rem; text-align: left;
}
.yaku-cards-row {
  display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;
}
.ref-card-wrapper {
  position: relative; transition: all 0.3s ease;
}
.mini-ref-card.card {
  width: 48px; height: 74px; margin: 0; flex-shrink: 0;
  transform: none; box-shadow: 2px 2px 5px rgba(0,0,0,0.8);
}
.mini-ref-card.card:hover, .mini-ref-card.card:active {
  transform: none; z-index: auto; box-shadow: 2px 2px 5px rgba(0,0,0,0.8);
}
.mini-ref-card .card-month-small { font-size: 0.5rem; top: 2px; left: 2px; }
.mini-ref-card .card-symbol { font-size: 1.6rem; }
.mini-ref-card.card.tanzaku::before { left: 5px; width: 6px; }

.ref-card-wrapper.missing .mini-ref-card {
  filter: grayscale(1) brightness(0.3) contrast(1.2);
  border-color: #4a3a2a; opacity: 0.7; background: #050505;
}
.ref-card-wrapper.collected .mini-ref-card {
  box-shadow: 0 0 10px rgba(205, 168, 105, 0.6);
  border-color: #ffa700; transform: scale(1.05); z-index: 10;
}

.hidden { display: none !important; }
</style>
</head>

<body>
<div class="container" id="game-container">

  <div class="decision-overlay hidden" id="decision-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1500;"></div>

  <div id="role-completion-notification" class="hidden" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1600; text-align: center; background: rgba(26,26,26,0.95); padding: 40px; border: 2px solid #ffa700; border-radius: 12px; box-shadow: 0 0 30px rgba(0,0,0,0.8); min-width: 300px;">
    <div class="role-owner-celebration" id="celebration-owner" style="font-size: 1.2rem; color: #aaa; margin-bottom: 10px;"></div>
    <div class="role-name-celebration" id="celebration-role-name"></div>
    <div id="slot-score-display" class="hidden">0</div>
    <div class="role-decision-buttons hidden" id="role-decision-buttons">
      <button class="role-koikoi-btn btn-gold" id="role-koikoi-btn" style="font-size: 1.2rem; padding: 15px 30px;">ğŸ²ã“ã„ã“ã„</button>
      <button class="role-win-btn btn-gold" id="role-win-btn" style="font-size: 1.2rem; padding: 15px 30px;">ğŸ‘‹å‹è² </button>
    </div>
  </div>

  <div style="display: flex; justify-content: space-between; padding: 10px;">
    <div>
      <button id="roles-btn" class="btn-gold">ğŸ“‹ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å›³é‘‘</button>
      <button id="reset-btn" class="btn-gold hidden">ğŸ”„ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
    <header style="font-size: 1.5rem; font-weight: bold; color: #cda869; letter-spacing: 0.2rem;">ğŸ´ã“ã„ã“ã„ï¼šæ¥µ</header>
  </div>

  <div class="message-section" style="text-align: center; margin-bottom: 10px; font-size: 1.2rem;">
    <div id="system-log">ğŸ¯æº–å‚™ãŒæ•´ã„ã¾ã—ãŸ</div>
  </div>

  <div class="opponent-section" id="opponent-section">
    <div class="opponent-paired" id="opponent-paired"></div>
    <div class="opponent-hand" id="opponent-hand"></div>
  </div>

  <div class="main-area">
    <div id="deck">
      <div class="deck-visual">ğŸ´</div>
      <span id="deck-count">24</span>
    </div>
    <div class="field-cards" id="field-cards-container">
      <div id="top-ui-area"></div>
      <div class="field-cards-row" id="field-cards"></div>
    </div>
  </div>

  <div class="hand-container">
    <div class="player-hand" id="player-hand"></div>
    <div class="player-paired" id="player-paired"></div>
  </div>

  <div class="bottom-controls" style="display: flex; justify-content: space-around; padding: 10px; background: rgba(0,0,0,0.5); border-top: 1px solid rgba(205, 168, 105, 0.3);">
    <div class="score-button" id="player-score-btn" style="text-align: center; font-size: 1.2rem;">
      <div id="player-score">ğŸ˜¯ã˜ã¶ã‚“ ğŸ’° 0 Pt</div>
    </div>
    <div class="score-button" id="opponent-score-btn" style="text-align: center; font-size: 1.2rem;">
      <div id="opponent-score">ğŸ¤–ã‚ã„ã¦ ğŸ’° 0 Pt</div>
    </div>
  </div>
</div>

<!-- å½¹å›³é‘‘ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="roles-modal-backdrop" class="role-overlay hidden">
  <div id="roles-modal-content">
    <header style="font-size: 1.5rem; color: #cda869; margin-bottom: 20px; text-align: center;">ğŸ´ åé›†çŠ¶æ³ï¼ˆå…¨24æšï¼‰</header>
    <div>
      <div class="yaku-category"><div id="hikari-list"></div></div>
      <div class="yaku-category"><div id="tane-list"></div></div>
      <div class="yaku-category"><div id="tanzaku-list"></div></div>
    </div>
    <div style="text-align: center; margin-top: 20px;">
      <button id="roles-modal-close-btn" class="btn-gold">âŒé–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<script>
// =========================================
// ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿
// =========================================
const HYPER_DECK = [
  { id: "m01-h", month: 1, name: "æ¾ã«é¶´", symbol: "ğŸ¦¢âœ¨", type: "hikari", tags: ["light", "crane"] },
  { id: "m01-t", month: 1, name: "æ¾ã«èµ¤çŸ­", symbol: "ğŸ”–ğŸ”´", type: "tanzaku", tags: ["akatan", "tanzaku"] },
  { id: "m02-n", month: 2, name: "æ¢…ã«é´¬", symbol: "ğŸ¦ğŸŒ¸", type: "tane", tags: ["bird"] },
  { id: "m02-t", month: 2, name: "æ¢…ã«èµ¤çŸ­", symbol: "ğŸ”–ğŸ”´", type: "tanzaku", tags: ["akatan", "tanzaku"] },
  { id: "m03-h", month: 3, name: "æ¡œã«å¹•", symbol: "â›ºâœ¨", type: "hikari", tags: ["light", "curtain"] },
  { id: "m03-t", month: 3, name: "æ¡œã«èµ¤çŸ­", symbol: "ğŸ”–ğŸ”´", type: "tanzaku", tags: ["akatan", "tanzaku"] },
  { id: "m04-n", month: 4, name: "è—¤ã«ä¸å¦‚å¸°", symbol: "ğŸ¦œğŸŒ¿", type: "tane", tags: ["bird"] },
  { id: "m04-t", month: 4, name: "è—¤ã«çŸ­å†Š", symbol: "ğŸ—ï¸", type: "tanzaku", tags: ["tanzaku"] },
  { id: "m05-n", month: 5, name: "è–è’²ã«å…«æ©‹", symbol: "ğŸŒ‰", type: "tane", tags: ["bridge"] },
  { id: "m05-t", month: 5, name: "è–è’²ã«çŸ­å†Š", symbol: "ğŸ—ï¸", type: "tanzaku", tags: ["tanzaku"] },
  { id: "m06-n", month: 6, name: "ç‰¡ä¸¹ã«è¶", symbol: "ğŸ¦‹ğŸŒº", type: "tane", tags: ["cho", "insect"] },
  { id: "m06-t", month: 6, name: "ç‰¡ä¸¹ã«é’çŸ­", symbol: "ğŸ”–ğŸ”µ", type: "tanzaku", tags: ["aotan", "tanzaku"] },
  { id: "m07-n", month: 7, name: "è©ã«çŒª", symbol: "ğŸ—ğŸŒ¾", type: "tane", tags: ["ino", "beast"] },
  { id: "m07-t", month: 7, name: "è©ã«çŸ­å†Š", symbol: "ğŸ—ï¸", type: "tanzaku", tags: ["tanzaku"] },
  { id: "m08-h", month: 8, name: "èŠ’ã«æœˆ", symbol: "ğŸŒ•âœ¨", type: "hikari", tags: ["light", "moon"] },
  { id: "m08-n", month: 8, name: "èŠ’ã«é›", symbol: "ğŸ¦†ğŸŒ•", type: "tane", tags: ["bird"] },
  { id: "m09-n", month: 9, name: "èŠã«ç›ƒ", symbol: "ğŸ¶ğŸŒ•", type: "tane", tags: ["cup"] },
  { id: "m09-t", month: 9, name: "èŠã«é’çŸ­", symbol: "ğŸ”–ğŸ”µ", type: "tanzaku", tags: ["aotan", "tanzaku"] },
  { id: "m10-n", month: 10, name: "ç´…è‘‰ã«é¹¿", symbol: "ğŸ¦ŒğŸ", type: "tane", tags: ["shika", "beast"] },
  { id: "m10-t", month: 10, name: "ç´…è‘‰ã«é’çŸ­", symbol: "ğŸ”–ğŸ”µ", type: "tanzaku", tags: ["aotan", "tanzaku"] },
  { id: "m11-h", month: 11, name: "æŸ³ã«é“é¢¨", symbol: "ğŸŒ‚âœ¨", type: "hikari", tags: ["light", "rain"] },
  { id: "m11-n", month: 11, name: "æŸ³ã«ç‡•", symbol: "ğŸ¦â˜”", type: "tane", tags: ["bird"] },
  { id: "m12-h", month: 12, name: "æ¡ã«é³³å‡°", symbol: "ğŸ¦…âœ¨", type: "hikari", tags: ["light", "phoenix"] },
  { id: "m12-n", month: 12, name: "æ¡ã®å½¹æœ­", symbol: "ğŸŒ¿", type: "tane", tags: ["special"] }
];

const YAKU_PHRASES = {
  "äº”å…‰": "ã€Œå¤©åœ°ã‚’çµ±ã¹ã‚‹ã€äº”ã¤ã®è‡³å®ã€",
  "å››å…‰": "ã€Œå¤œç©ºã‚’ç…§ã‚‰ã™ã€å››ã¤ã®ç¬ãã€",
  "ä¸‰å…‰": "ã€Œå¤œæ˜ã‘ã‚’å¾…ã¤ã€ä¸‰ã¤ã®å¸Œæœ›ã€",
  "çŒªé¹¿è¶": "ã€Œä¹±ä¸–ã‚’èˆã†ã€ç”Ÿå‘½ã®è¼ªèˆæ›²ã€",
  "èµ¤çŸ­": "ã€Œæƒ…ç†±ã‚’ç¶´ã‚‹ã€æ·±ç´…ã®è¨€ã®è‘‰ã€",
  "é’çŸ­": "ã€Œé™å¯‚ã‚’è© ã‚€ã€ç´ºé’ã®åæ¯ã€",
  "ã‚¿ãƒ": "ã€Œé‡ã«æ¯ã¥ãã€å¤šæ§˜ãªã‚‹å‘½ã€",
  "çŸ­å†Š": "ã€Œé¢¨ã«æºã‚Œã‚‹ã€é¡˜ã„ã®é£¾ã‚Šã€"
};

// =========================================
// åˆ¤å®šãƒ»è¨˜éŒ²ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ (v19)
// =========================================
class HyperJudge {
  constructor() {
    this.yakuMap = {
      "äº”å…‰": { tags: ["light"], count: 5, points: 20 },
      "å››å…‰": { tags: ["light"], count: 4, points: 10 },
      "ä¸‰å…‰": { tags: ["light"], count: 3, points: 6 },
      "çŒªé¹¿è¶": { tags: ["ino", "shika", "cho"], points: 10 },
      "èµ¤çŸ­": { tags: ["akatan"], count: 3, points: 7 },
      "é’çŸ­": { tags: ["aotan"], count: 3, points: 7 },
      "ã‚¿ãƒ": { type: "tane", min: 3 },
      "çŸ­å†Š": { type: "tanzaku", min: 3 }
    };
  }
  check(cards) {
    const results = [];
    const types = { tane: 0, tanzaku: 0 };
    const myTags = cards.flatMap(c => c.tags || []);

    Object.entries(this.yakuMap).forEach(([name, rule]) => {
      if (rule.tags && (rule.count ? myTags.filter(t => rule.tags.includes(t)).length >= rule.count : rule.tags.every(t => myTags.includes(t)))) {
        if(name==="ä¸‰å…‰" && myTags.filter(t => t==='light').length >= 4) return;
        if(name==="å››å…‰" && myTags.filter(t => t==='light').length >= 5) return;
        results.push({ name, points: rule.points });
      }
    });

    cards.forEach(c => { if(types[c.type] !== undefined) types[c.type]++; });
    if (types.tane >= 3) results.push({ name: "ã‚¿ãƒ", points: types.tane - 2 });
    if (types.tanzaku >= 3) results.push({ name: "çŸ­å†Š", points: types.tanzaku - 2 });

    return results;
  }
}

class RecordManager {
  constructor() {
    this.key = 'KYOKU_DATA';
    this.data = JSON.parse(localStorage.getItem(this.key)) || { points: 0, wins: 0, playCount: 0, collectedCardIds: [] };
    if (!this.data.collectedCardIds) this.data.collectedCardIds = [];
  }
  update(p, isWin) {
    this.data.points += p;
    if (isWin) this.data.wins++;
    this.data.playCount++;
    localStorage.setItem(this.key, JSON.stringify(this.data));
  }
  updateCollection(cards) {
    let updated = false;
    cards.forEach(card => {
      if (!this.data.collectedCardIds.includes(card.id)) {
        this.data.collectedCardIds.push(card.id);
        updated = true;
      }
    });
    if (updated) localStorage.setItem(this.key, JSON.stringify(this.data));
  }
  getRank() {
    const count = this.data.collectedCardIds.length;
    if (count === 24) return "ğŸ‘‘ ä¸‡ç‰©åé›†ã®æ¥µã¿ï¼ˆã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆï¼‰";
    if (count >= 18)  return "âœ¨ ç†Ÿç·´ã®åé›†å®¶";
    if (count >= 10)  return "ğŸ´ ç²‹ãªéŠã³äºº";
    if (count >= 1)   return "ğŸŒ± è¦‹ç¿’ã„åé›†å®¶";
    return "ğŸŒ± é–€å¤–æ¼¢";
  }
  getCollectionRate() {
    return this.data.collectedCardIds.length;
  }
}

class StatusSyncManager {
  constructor(game) { this.game = game; }

  sync() {
    // å›³é‘‘ã®æç”»ï¼šãƒŸãƒ‹ãƒãƒ¥ã‚¢æ¨™æœ¬ç®±å½¢å¼
    ['hikari', 'tane', 'tanzaku'].forEach(type => {
      const listEl = document.getElementById(`${type}-list`);
      if(!listEl) return;

      const typeMasters = HYPER_DECK.filter(d => d.type === type);
      const typeNames = { hikari: "âœ¨ å…‰æœ­ï¼ˆå…¨5ç¨®ï¼‰", tane: "ğŸ¦… ç¨®æœ­ï¼ˆå…¨9ç¨®ï¼‰", tanzaku: "ğŸ”– çŸ­å†Šæœ­ï¼ˆå…¨10ç¨®ï¼‰" };

      const cardsHTML = typeMasters.map(master => {
        const isCollected = this.game.record.data.collectedCardIds.includes(master.id);
        const tagClasses = master.tags ? master.tags.join(' ') : '';
        const tanzakuDeco = master.type === 'tanzaku' ? `<div class="tanzaku-line ${master.tags.includes('akatan')?'red':'blue'}"></div>` : '';

        return `
          <div class="ref-card-wrapper ${isCollected ? 'collected' : 'missing'}">
            <div class="card ${master.type} ${tagClasses} mini-ref-card">
              ${tanzakuDeco}
              <div class="card-month-small">${master.month}æœˆ</div>
              <div class="card-main-visual"><span class="card-symbol">${master.symbol}</span></div>
            </div>
          </div>
        `;
      }).join('');

      listEl.innerHTML = `
        <div class="yaku-specimen-box">
          <div class="yaku-header">
            <span class="yaku-name">${typeNames[type]}</span>
          </div>
          <div class="yaku-cards-row">
            ${cardsHTML}
          </div>
        </div>
      `;
    });

    this.game.ui.pScore.innerText = `ğŸ˜¯ã˜ã¶ã‚“ ğŸ’° ${this.game.calculateCurrentPoints(this.game.playerCollected)} Pt`;
    this.game.ui.oScore.innerText = `ğŸ¤–ã‚ã„ã¦ ğŸ’° ${this.game.calculateCurrentPoints(this.game.opponentCollected)} Pt`;
  }
}

function moveCard(cardElement, targetAreaElement, onComplete) {
  if (!cardElement || !targetAreaElement) return onComplete && onComplete();
  const startRect = cardElement.getBoundingClientRect();
  const endRect = targetAreaElement.getBoundingClientRect();
  cardElement.style.transition = "transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s";
  cardElement.style.transform = `translate(${endRect.left - startRect.left}px, ${endRect.top - startRect.top}px) scale(0.8)`;
  cardElement.style.zIndex = "1000";
  cardElement.addEventListener('transitionend', () => {
    cardElement.style.transition = "none";
    cardElement.style.transform = "none";
    targetAreaElement.appendChild(cardElement);
    if (onComplete) onComplete();
  }, { once: true });
}

// =========================================
// ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
// =========================================
class GameController {
  constructor() {
    this.judge = new HyperJudge();
    this.record = new RecordManager();
    this.sync = new StatusSyncManager(this);
    this.state = 'IDLE';

    this.ui = {
      game: document.getElementById('game-container'),
      field: document.getElementById('field-cards'),
      topUiArea: document.getElementById('top-ui-area'),
      pHand: document.getElementById('player-hand'),
      oHand: document.getElementById('opponent-hand'),
      pScore: document.getElementById('player-score'),
      oScore: document.getElementById('opponent-score'),
      deckCount: document.getElementById('deck-count'),
      deck: document.getElementById('deck'),
      log: document.getElementById('system-log'),
      overlay: document.getElementById('decision-overlay'),
      owner: document.getElementById('celebration-owner'),
      role: document.getElementById('celebration-role-name'),
      slot: document.getElementById('slot-score-display'),
      btns: document.getElementById('role-decision-buttons'),
      reset: document.getElementById('reset-btn'),
      notification: document.getElementById('role-completion-notification'),
      opponentSection: document.getElementById('opponent-section')
    };

    this.init();
  }

  init() {
    document.body.classList.add('is-opening');
    this.prepareTop();
    this.bindEvents();
    this.sync.sync(); // åˆæœŸçŠ¶æ…‹ã§ã‚‚å›³é‘‘ã‚’è¦‹ã‚Œã‚‹ã‚ˆã†ã«
  }

  prepareTop() {
    this.ui.topUiArea.innerHTML = `
      <div class="opening-ceremony" style="text-align: center; padding: 40px 20px;">
        <h2 style="font-size: 3rem; letter-spacing: 0.8rem; color: #cda869; margin-bottom: 30px;">ã“ã„ã“ã„ï¼šæ¥µ</h2>
        <div style="font-style: italic; color: #f0e68c; margin-bottom: 30px; font-size: 1.2rem;">ã€Œæ¥µä¸Šã®å‹è² ãŒã€ä»Šå§‹ã¾ã‚‹ã€‚ã€</div>
        <div id="player-rank-display" style="margin-bottom: 40px;">
          ç¾åœ¨ã®åœ°ä½ï¼š${this.record.getRank()}<br>
          <span style="font-size: 0.9rem; color: #aaa;">å›³é‘‘åé›†ç‡ï¼š${this.record.getCollectionRate()} / 24 æš</span>
        </div>
        <button id="start-btn" class="btn-gold" style="padding: 15px 50px; font-size: 1.5rem;">ä¸€å±€æ‰“ã¤</button>
      </div>
    `;

    document.getElementById('start-btn').onclick = () => {
      this.ui.topUiArea.innerHTML = '';
      this.start();
    };
  }

  start() {
    document.body.classList.remove('is-opening');
    this.deck = [...HYPER_DECK].sort(() => Math.random() - 0.5);
    this.playerHand = []; this.opponentHand = []; this.field = [];
    this.playerCollected = []; this.opponentCollected = [];

    this.ui.reset.classList.remove('hidden');
    this.deal();

    const initialResult = this.checkInitialHand(this.playerHand);
    if(initialResult) {
      this.forceDraw(initialResult);
      return;
    }

    this.sync.sync();
    this.state = 'PLAYER_TURN';
    this.ui.log.innerText = "ğŸ˜¯ ã‚ãªãŸã®ç•ªã§ã™";
  }

  checkInitialHand(hand) {
    const counts = {};
    hand.forEach(c => counts[c.month] = (counts[c.month] || 0) + 1);
    if (Object.values(counts).some(v => v === 4)) return "æ‰‹å››";
    if (Object.values(counts).filter(v => v === 2).length === 3) return "ãã£ã¤ã";
    return null;
  }

  forceDraw(reason) {
    this.state = 'END';
    this.ui.log.innerText = `ğŸ´ ç‰¹æ®Šæ¡ä»¶ï¼š${reason}`;
    this.ui.overlay.classList.remove('hidden');
    this.ui.notification.classList.remove('hidden');
    this.ui.owner.innerText = "ğŸ´ æµå±€";
    this.ui.role.innerText = `${reason}ã«ã‚ˆã‚Šå†è©¦åˆ`;
    this.ui.btns.classList.add('hidden');
    this.ui.slot.classList.add('hidden');
    this.ui.reset.classList.remove('hidden');
    this.ui.reset.innerText = "ğŸ”„ æ¬¡ã®å±€ã¸";
  }

  createCardUI(data) {
    const div = document.createElement('div');
    const tagClasses = data.tags ? data.tags.join(' ') : '';
    div.className = `card ${data.type} ${tagClasses}`;
    div.innerHTML = `
      <div class="card-month-small">${data.month}æœˆ</div>
      <div class="card-main-visual"><span class="card-symbol">${data.symbol}</span></div>
      <div class="card-label-hidden">${data.name}</div>
    `;
    return div;
  }

  addToField(data) {
    const el = this.createCardUI(data);
    this.field.push({ ...data, element: el });
    this.ui.field.appendChild(el);
  }

  addToHand(data, isPlayer) {
    const el = this.createCardUI(data);
    const cardObj = { ...data, element: el };
    if (isPlayer) {
      this.playerHand.push(cardObj);
      el.onclick = () => this.executePlayerTurn(cardObj);
      this.ui.pHand.appendChild(el);
    } else {
      this.opponentHand.push(cardObj);
      el.innerHTML = `<div class="card-back">ğŸ´</div>`;
      this.ui.oHand.appendChild(el);
    }
  }

  deal() {
    for (let i = 0; i < 4; i++) this.addToField(this.deck.pop());
    for (let i = 0; i < 6; i++) this.addToHand(this.deck.pop(), true);
    for (let i = 0; i < 6; i++) this.addToHand(this.deck.pop(), false);
    this.updateDeck();
    this.adjustCardOverlap('player-hand');
    this.adjustCardOverlap('opponent-hand');
  }

  updateDeck() {
    if (this.ui.deckCount) this.ui.deckCount.innerText = this.deck.length;
  }

  calculateCurrentPoints(cards) {
    return this.judge.check(cards).reduce((sum, y) => sum + y.points, 0);
  }

  highlightMatches(selectedCard) {
    this.field.forEach(f => f.element.classList.remove('match-highlight'));
    const match = this.field.find(f => f.month === selectedCard.month);
    if (match) match.element.classList.add('match-highlight');
  }

  async animate(el, destId) {
    const dest = document.getElementById(destId);
    return new Promise(resolve => {
      if (destId.includes('paired')) {
        el.style.transform = destId === 'opponent-paired' ? "scale(0.5)" : "scale(0.6)";
        el.style.transition = "transform 0.5s, margin 0.5s";
        const count = dest.children.length;
        el.style.marginLeft = destId === 'opponent-paired' ? "-25px" : "-55px";
        el.style.zIndex = count;
      } else if(destId.includes('hand')){
        el.style.transform = "none";
      }
      moveCard(el, dest, resolve);
    });
  }

  adjustCardOverlap(containerId) {
    const container = document.getElementById(containerId);
    const cards = container.querySelectorAll('.card');
    cards.forEach((card, index) => {
      card.style.marginLeft = index === 0 ? "0px" : "-35px";
      card.style.zIndex = index;
    });
  }

  async executePlayerTurn(card) {
    if (this.state !== 'PLAYER_TURN') return;
    card.element.style.boxShadow = "0 0 20px gold";
    card.element.style.transform = "translateY(-20px)";
    this.highlightMatches(card);
    this.state = 'ANIMATING';
    await this.handleHandAction(card, true);
  }

  async executeOpponentTurn() {
    if (this.state !== 'OPPONENT_TURN') return;
    this.ui.log.innerHTML = `<span class="thinking-dot">ğŸ¤– ã‚ã„ã¦ãŒè€ƒæ¡ˆä¸­...</span>`;

    const timeoutId = setTimeout(() => {
      this.finalizeOpponentTurn();
    }, 5000);

    try {
      await new Promise(r => setTimeout(r, 1500));
      let card = this.opponentHand.find(h => this.field.some(f => f.month === h.month));
      if (!card) card = this.opponentHand;
      if (!card) throw new Error("å‡ºã™æœ­ãŒã‚ã‚Šã¾ã›ã‚“");

      card.element.innerHTML = `
        <div class="card-month-small">${card.month}æœˆ</div>
        <div class="card-main-visual"><span class="card-symbol">${card.symbol}</span></div>
      `;

      await this.handleHandAction(card, false);
    } catch (error) {
      console.error(error);
    } finally {
      clearTimeout(timeoutId);
      this.ui.opponentSection.classList.remove('active');
      this.finalizeOpponentTurn();
    }
  }

  finalizeOpponentTurn() {
    if (this.state === 'OPPONENT_TURN') {
      this.state = 'PLAYER_TURN';
      this.ui.log.innerText = "ğŸ˜¯ ã‚ãªãŸã®ç•ªã§ã™";
    }
  }

  async handleHandAction(card, isPlayer) {
    const destId = isPlayer ? 'player-paired' : 'opponent-paired';
    const collected = isPlayer ? this.playerCollected : this.opponentCollected;
    const match = this.field.find(f => f.month === card.month);

    if (match) {
      match.element.classList.remove('match-highlight');
      this.field = this.field.filter(f => f !== match);
      await Promise.all([this.animate(card.element, destId), this.animate(match.element, destId)]);
      collected.push(card, match);
    } else {
      await this.animate(card.element, 'field-cards');
      this.field.push(card);
    }

    if (isPlayer) {
      this.playerHand = this.playerHand.filter(h => h !== card);
      this.adjustCardOverlap('player-hand');
    } else {
      this.opponentHand = this.opponentHand.filter(h => h !== card);
      this.adjustCardOverlap('opponent-hand');
    }

    if (this.deck.length > 0) {
      this.state = 'WAIT_DECK';
      this.ui.deck.classList.add('active-guide');
      this.ui.log.innerText = isPlayer ? "ğŸ´ å±±æœ­ã‚’ã‚ãã£ã¦ãã ã•ã„" : "ğŸ¤– å±±æœ­ã‚’ã‚ãã‚Šã¾ã™...";

      if (!isPlayer) {
        await new Promise(r => setTimeout(r, 1000));
        await this.handleDeckAction(false);
      }
    } else {
      await this.finalizeTurn(isPlayer);
    }
  }

  async handleDeckAction(isPlayer) {
    if (isPlayer && this.state !== 'WAIT_DECK') return;

    this.state = 'ANIMATING';
    this.ui.deck.classList.remove('active-guide');

    const destId = isPlayer ? 'player-paired' : 'opponent-paired';
    const collected = isPlayer ? this.playerCollected : this.opponentCollected;

    const drawnData = this.deck.pop();
    const el = this.createCardUI(drawnData);
    const obj = { ...drawnData, element: el };

    el.style.position = 'absolute';
    el.style.left = '0';
    el.style.top = '0';
    this.ui.deck.appendChild(el);

    const dMatch = this.field.find(f => f.month === obj.month);

    if (dMatch) {
      this.field = this.field.filter(f => f !== dMatch);
      await Promise.all([this.animate(el, destId), this.animate(dMatch.element, destId)]);
      collected.push(obj, dMatch);
    } else {
      await this.animate(el, 'field-cards');
      this.field.push(obj);
    }

    this.updateDeck();
    await this.finalizeTurn(isPlayer);
  }

  async finalizeTurn(isPlayer) {
    this.sync.sync();
    const collected = isPlayer ? this.playerCollected : this.opponentCollected;
    const yaku = this.judge.check(collected);

    if (yaku.length > 0) {
      await this.showResult(yaku, isPlayer);
    } else {
      if (isPlayer) {
        this.state = 'OPPONENT_TURN';
        this.executeOpponentTurn();
      } else {
        this.state = 'PLAYER_TURN';
        this.ui.log.innerText = "ğŸ˜¯ ã‚ãªãŸã®ç•ªã§ã™";
        this.checkEnd();
      }
    }
  }

  async showResult(yaku, isPlayer) {
    this.state = 'DECISION';
    const latestYaku = yaku[yaku.length - 1];

    if (latestYaku.name === "äº”å…‰") await this.triggerDivineEffect();
    else if (latestYaku.name === "çŒªé¹¿è¶") this.createButterflies();

    this.ui.game.classList.add('celebration-mode');
    this.createGoldLeaf();

    this.ui.owner.innerText = isPlayer ? "ğŸ˜¯ ã‚ãªãŸã®å½¹" : "ğŸ¤– ã‚ã„ã¦ã®å½¹";

    const phrase = YAKU_PHRASES[latestYaku.name] || "ã€Œé‹å‘½ãŒã€ä»Šå‹•ãå‡ºã™ã€";
    this.ui.role.innerHTML = `
      <div style="font-size: 1.1rem; font-style: italic; color: #fff7ad; margin-bottom: 8px;">${phrase}</div>
      <div style="letter-spacing: 0.3rem;">âœ¨ ${latestYaku.name} âœ¨</div>
    `;

    this.ui.overlay.classList.remove('hidden');
    this.ui.notification.classList.remove('hidden');
    this.ui.btns.classList.remove('hidden');
    this.ui.slot.classList.add('hidden');
    this.ui.reset.classList.add('hidden');

    if (!isPlayer) setTimeout(() => this.handleAIDecision(yaku), 2500);
  }

  async triggerDivineEffect() {
    const flash = document.createElement('div');
    flash.className = 'divine-flash-overlay';
    document.body.appendChild(flash);
    setTimeout(() => flash.classList.add('active'), 10);
    const cards = document.querySelectorAll('.card');
    cards.forEach(c => c.classList.add('divine-fade-out'));

    await new Promise(r => setTimeout(r, 600));
    flash.classList.remove('active');
    this.ui.role.classList.add('yaku-divine');

    setTimeout(() => {
      flash.remove();
      cards.forEach(c => c.classList.remove('divine-fade-out'));
    }, 1000);
  }

  createGoldLeaf() {
    for (let i = 0; i < 50; i++) {
      const leaf = document.createElement('div');
      leaf.className = 'gold-particle';
      const duration = 2 + Math.random() * 3;
      const delay = Math.random() * 2;
      leaf.style.left = Math.random() * 100 + 'vw';
      leaf.style.width = (6 + Math.random() * 8) + 'px';
      leaf.style.height = leaf.style.width;
      leaf.style.animation = `fall ${duration}s linear ${delay}s forwards`;
      document.body.appendChild(leaf);
      setTimeout(() => leaf.remove(), (duration + delay) * 1000);
    }
  }

  createButterflies() {
    for (let i = 0; i < 20; i++) {
      const b = document.createElement('div');
      b.className = 'butterfly-particle';
      b.innerText = 'ğŸ¦‹';
      b.style.left = '50vw';
      b.style.top = '50vh';
      const angle = Math.random() * Math.PI * 2;
      const dist = 30 + Math.random() * 50;
      b.style.setProperty('--tx', (Math.cos(angle) * dist) + 'vw');
      b.style.setProperty('--ty', (Math.sin(angle) * dist) + 'vh');
      b.style.animation = `butterfly-fly ${2 + Math.random() * 2}s ease-out forwards`;
      document.body.appendChild(b);
      setTimeout(() => b.remove(), 4000);
    }
  }

  handleAIDecision(yaku) {
    const shouldKoikoi = this.deck.length > 3 && Math.random() > 0.5;
    if (shouldKoikoi) {
      this.ui.log.innerText = "ğŸ¤– ã‚ã„ã¦ï¼šã“ã„ã“ã„ï¼";
      this.ui.game.classList.remove('celebration-mode');
      this.ui.overlay.classList.add('hidden');
      this.ui.notification.classList.add('hidden');
      setTimeout(() => {
        this.state = 'PLAYER_TURN';
        this.ui.log.innerText = "ğŸ˜¯ ã‚ãªãŸã®ç•ªã§ã™";
      }, 1000);
    } else {
      this.triggerWin(false, yaku);
    }
  }

  triggerWin(isPlayer, yaku) {
    const totalPoints = yaku.reduce((sum, y) => sum + y.points, 0);
    this.ui.notification.classList.remove('hidden');
    this.ui.btns.classList.add('hidden');
    this.ui.slot.classList.remove('hidden');
    this.ui.overlay.classList.remove('hidden');

    let current = 0;
    const step = Math.ceil(totalPoints / 20);
    const timer = setInterval(() => {
      current += step;
      if (current >= totalPoints) {
        current = totalPoints;
        clearInterval(timer);
        this.finalizeScore(isPlayer, totalPoints);
      }
      this.ui.slot.innerText = current;
    }, 50);
  }

  finalizeScore(isPlayer, points) {
    const currentP = this.calculateCurrentPoints(this.playerCollected);
    const currentO = this.calculateCurrentPoints(this.opponentCollected);
    this.ui.pScore.innerHTML = `ğŸ˜¯ã˜ã¶ã‚“ ğŸ’° ${currentP + (isPlayer ? points : 0)} Pt`;
    this.ui.oScore.innerHTML = `ğŸ¤–ã‚ã„ã¦ ğŸ’° ${currentO + (!isPlayer ? points : 0)} Pt`;

    // v19: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹åˆ©æ™‚ã«ç²å¾—ã—ãŸæœ­ã‚’å›³é‘‘ã«ç™»éŒ²
    if (isPlayer) {
      this.record.update(points, true);
      this.record.updateCollection(this.playerCollected);
    } else {
      this.record.update(0, false);
    }

    this.ui.owner.innerText = "ğŸŠ çµ‚å±€ ğŸŠ";
    this.ui.reset.classList.remove('hidden');
    this.ui.reset.innerText = "ğŸ”„ æ¬¡ã®å±€ã¸";
    this.state = 'END';
  }

  checkEnd() {
    if (this.playerHand.length === 0 && this.opponentHand.length === 0) {
      this.state = 'END';
      this.ui.log.innerText = "ğŸ´ æµã‚Œï¼ˆå¼•ãåˆ†ã‘ï¼‰ã§ã™";
      this.ui.overlay.classList.remove('hidden');
      this.ui.notification.classList.remove('hidden');
      this.ui.owner.innerText = "ğŸ´ æµã‚Œ";
      this.ui.role.innerText = "è¦ªãªã—ãƒ»å¼•ãåˆ†ã‘";
      this.ui.btns.classList.add('hidden');
      this.ui.slot.classList.add('hidden');
      this.ui.reset.classList.remove('hidden');
      this.ui.reset.innerText = "ğŸ”„ æ¬¡ã®å±€ã¸";
    }
  }

  bindEvents() {
    this.ui.reset.onclick = () => {
      if (this.state === 'END' || confirm("å¯¾å±€ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) location.reload();
    };

    document.getElementById('roles-btn').onclick = () => {
      this.sync.sync();
      document.getElementById('roles-modal-backdrop').classList.remove('hidden');
    };
    document.getElementById('roles-modal-close-btn').onclick = () => {
      document.getElementById('roles-modal-backdrop').classList.add('hidden');
    };

    document.getElementById('role-win-btn').onclick = () => {
      const yaku = this.judge.check(this.playerCollected);
      this.triggerWin(true, yaku);
    };

    document.getElementById('role-koikoi-btn').onclick = () => {
      this.ui.overlay.classList.add('hidden');
      this.ui.notification.classList.add('hidden');
      this.ui.game.classList.remove('celebration-mode');
      this.ui.log.innerText = "ğŸ² ã“ã„ã“ã„ï¼ç¶šè¡Œã—ã¾ã™";
      this.executeOpponentTurn();
    };

    this.ui.deck.onclick = () => {
      if(this.state === 'WAIT_DECK') this.handleDeckAction(true);
    };
  }
}

new GameController();
</script>
</body>
</html>





